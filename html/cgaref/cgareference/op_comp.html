<html>

<head>
	<title>Component Split Operation</title>
	<link rel="stylesheet" href="../manual_style.css" type="text/css" />
</head>

<body>
<div class="content">

<table summary="" class="header">
	<tr>
		<td align="left" class="helphead_l"><a href="../toc.html"><div class="helplink">&nbsp;</div></a></td>
		<td align="right" class="helphead_r"></td>
	</tr>
</table>

<h1>comp operation</h1>

<h2>Syntax</h2>

<p class="code2">comp(<span class="cga_opparam">component</span>) { <span class="cga_opparam">selector</span> <span class="cga_opparam">operator</span> <span class="cga_opparam">operations</span> | <span class="cga_opparam">selector</span> <span class="cga_opparam">operator</span> <span class="cga_opparam">operations</span> ... }</p>

<h2 id="params">Parameters</h2>

<ul>
	<li><span class="cga_opparam">component</span> (selector)<br>The component into which to split:
		<table cellspacing="5">
		<tr><td width="30%"><span class="codelight">f</span></td><td>faces</td></tr>
		<tr><td><span class="codelight">e</span></td><td>edges</td></tr>
		<tr><td><span class="codelight">fe</span></td><td>face edges</td></tr>
		<tr><td><span class="codelight">v</span></td><td>vertices</td></tr>
		<tr><td><span class="codelight">g</span></td><td>groups</td></tr>
		<tr><td><span class="codelight">m</span></td><td>materials</td></tr>
		<tr><td><span class="codelight">h</span></td><td>holes</td></tr>
		</table>
	</li>
	<li><span class="cga_opparam">selector</span> (selector, bool, float)
		<table cellspacing="5">
		<tr><td width="40%"><span class="codelight">front, back, left, right, top, bottom</span></td><td>The y-normals of the components are analyzed by classifying their directions into the corresponding quadrants (in relation to the local coordinate system of the current shape).</td></tr>
		<tr><td><span class="codelight">object.front, object.back, object.left, object.right, object.top, object.bottom, object.side</span></td><td>The y-normals of the components are analyzed by classifying their directions into the corresponding quadrants (in relation to the local coordinate system of the current shape).</td></tr>
		<tr><td><span class="codelight">world.south, world.north, world.west, world.east, world.up, world.down, world.side</span></td><td>The y-normals of the components are analyzed by classifying their directions into the corresponding quadrants (in relation to the world coordinate system).</td></tr>
		<tr><td><span class="codelight">vertical, horizontal, aslant, nutant</span></td><td>The y-normals are analyzed in relation to the xz-plane of the current shape's local coordinate system. The the angle between normals and xz-plane is used to classify the components. The exact ranges are (in degrees):
		<table cellspacing="5">
		<tr><td><span class="codelight">horizontal</span></td><td>]78.75, 90]</td></tr>
		<tr><td><span class="codelight">aslant</span></td><td>]11.25, 78.75]</td></tr>
		<tr><td><span class="codelight">vertical</span></td><td>]-11.25, 11.25]</td></tr>
		<tr><td><span class="codelight">nutant</span></td><td>]-78.55, -11.25]</td></tr>
		<tr><td><span class="codelight">horizontal</span></td><td>[-90, -78.75]</td></tr>
		</table></td></tr>
		<tr><td><span class="codelight">side</span></td><td>Selects all but the horizontal components.</td></tr>
		<tr><td><span class="codelight">border, inside</span></td><td>Components at the border of or fully inside the geometry respectively. Border edges are connected to only one face; border faces contain one or more border edges; border vertices are start or end point of one or more border edges. This selector does not work on holes.</td></tr>
		<tr><td><span class="codelight">eave, hip, valley, ridge</span></td><td>These selectors work on edges only and are designed to be used in conjunction with roofs. See the <a href="op_comp.html#roofEdges" class="xref">section below</a> for more details.</td></tr>
		<tr><td><span class="codelight">street.front, street.back, street.left, street.right, street.side</span></td><td>If the streetWidth attribute is available on the initial shape, these selectors can be used to identify street-facing components. See the <a href="op_comp.html#streetSelectors" class="xref">section below</a> for more details.</td></tr>
		<tr><td><span class="codelight">all</span></td><td>Selects all components.</td></tr>
		<tr><td><span class="codelight">isTagged(<span class="cga_opparam">tagQuery</span>),</span> <br>
				<span class="codelight">isTagged(<span class="cga_opparam">tagQuery, subcomponent</span>)</span></td><td>Selects tagged components. See the <a href="op_comp.html#isTagged" class="xref">section below</a> for more details.
		<ul style="padding-left: 0px; margin-left: 20px; list-style-position: outside;">
			<li><span class="cga_opparam">tagQuery</span> (string)<br>The <a href="cga_componentTags.html#tagQueries" class="xref">tag query</a>.
			</li>
			<li><span class="cga_opparam">subcomponent</span> (selector)
				
				<table cellspacing="5">
					<tr><td width="15%"><span class="codelight">e, v</span></td><td>If specified, components are selected if <span class="cga_opparam">tagQuery</span> matches any of their subcomponents (edges or vertices) instead. See the <a href="op_comp.html#isTagged_advanced" class="xref">section below</a> for more details.</td></tr>
				</table>
			</li>
		</ul>
		<p class="notes"><em>Tags stored on a face also identify its edges and vertices, while tags stored on an edge also identify its two vertex endpoints.</em></p>
		</td></tr>
		<tr><td> <i>logical expression (bool)</i></td><td>Selects all components for which the expression evaluates to true. User-defined functions as well as the above selectors can be used in the expression.</td></tr>
		<tr><td> <i>index (float)</i></td><td> Selects the <i>index</i>-th component (0-based).</td></tr>
		</table>
	</li>
	<li><span class="cga_opparam">operator</span><br>The operator defines how the selected components are used to generate successor shapes.
		<table cellspacing="5">
		<tr><td width="10%"><span class="codelight">:</span></td><td>Each selected component is put into a new shape.</td></tr>
		<tr><td><span class="codelight">=</span></td><td>All selected components are combined into one new shape.</td></tr>
		</table>
	</li>
	<li><span class="cga_opparam">operations</span><br>A sequence of shape operations to execute on the newly created shape.</li>
</ul>

<h2>Description</h2>

<p>The <span class="codelight">comp</span> operation (component split) allows to divide a shape into its topological components, which are either faces, edges, face edges, vertices, groups, materials or holes. 
The components can be selected using either their <i>index</i> or a set of selectors. Group and material components satisfy a specific selection keyword if at least one geometric component (usually a face) satifies it. The selected components are transformed to a new shape and processed by a sequence of shape operations. Depending on the <span class="cga_opparam">operator</span>, either one shape is created for each individual selected component (&quot;:&quot;) ore one shape for the whole set of selected components (&quot;=&quot;).</p>

<p class="text">The selection parameters of a component split work in a excluding manner: if a parameter has selected a specific component, this component cannot be part of another selection (from left to right).</p>

<p class="text">The local coordinate systems (<span class="codelight">pivot</span> and <span class="codelight">scope</span>) of the newly generated shapes are aligned according to the geometry's topology; the component split is one of the few shape operations which manipulate the pivot of a shape.</p>

<table cellspacing="5">
<tr><td><span class="codelight">f</span></td><td>In the case of a face component split, the x-axis is directed as the first edge of the face and the z-axis points along the face normal. The pivot is positioned at the first vertex of the first edge of the face; the scope is the bounding box of the face, i.e. the z-dimension of the emerging shape's scope is set to zero. See an <a href="#faceDetails">example</a>.</td></tr>
<tr><td><span class="codelight">e</span></td><td>In the case of an edge component split, the x-axes of the pivot and scope are along the edge and the z-axes points along the average of the neighboring face normals. The y- and z-dimension of the scope are set to zero and the x-dimension is the length of the edge. The pivot is positioned at one of the endpoints of the edge. The indexing of edges is as follows: Index 0 is the first edge of the first face, index 1 the second edge of the first face etc. Shared edges are skipped on second encounter. See an <a href="#edgeDetails">example</a>.</td></tr>
<tr><td><span class="codelight">fe</span></td><td>In contrast to edges, face edges are considered separate for each face. Similarly, indexing is done firstly per face and secondly per edge, but shared edges are not skipped. Furthermore, contrary to edges, face edges have a unique direction determined by the orientation of the face they belong to. The x-axes of the pivot and the scope are directed in face orientation and the z-axes point out of the face orthogonally to the edge and the face normal. The pivot is positioned at the first vertex of the face edge. See an <a href="#edgeDetails">example</a>.</td></tr>
<tr><td><span class="codelight">v</span></td><td>In case of a vertex component split, the pivot is positioned at the vertex, the z-axes points along the average of the neighboring face normals and all scope dimensions are set to zero. See an <a href="#vertexDetails">example</a>.</td></tr>
</table>

<h3 class="text">Comp shape attributes</h3>

<p class="text">Each generated shape has a number of comp shape attributes set. For more information see <a class="normw" href="attr_comp.html">comp attribute</a>.</p>
            
<a name="trimPlanes"></a><h3>Trim Planes</h3>
  
<p>Additionally, <em>for faces</em>, the component split generates <i>trim planes</i>. Trim planes are placed along the shared edges of the new faces in a bisecting angle. The purpose of trim planes is twofold. On one side, trimming handles geometry intersections on the boundary of two neighboring faces, and on the other side, trimming is used to handle non-rectangular faces. The trim planes are applied using the <a class="normw" href="op_i.html#trim">insert operation</a>, <a class="normw" href="op_primitive.html">primitive operations</a>, or the <a class="normw" href="op_trim.html">trim</a> operation.</p>

<p>According to the direction of the shared edge, trim planes are classified into horizontal and vertical planes. They can be switched on or off by <a class="normw" href="op_set.html">setting</a> the <a class="normw" href="attr_trim.html">trim attribute</a> to true or false. By default, trimming is activated for vertical trim planes and deactivated for horizontal trim planes. Check the trim planes examples <a class="normw" href="#trimExamples">below</a>.</p>

<p class="notes"><em>Trim planes are only generated if the : operator is used!</em></p>

<p>Trim planes can be configured in the <a href="https://doc.arcgis.com/en/cityengine/latest/help/get-started-preferences-prt.htm" target="_blank">Procedural Runtime preferences</a>.</p>

<h3>Occluder shape</h3>

<p>An occluder shape is automatically generated before the component split is applied. The occluder shape is made available for unlabeled <a href="func_occlusion.html">occlusion queries</a>.</p>

<a name="roofEdges"></a><h3>Roof Edges</h3>

<p>There is a number of selectors which are designed to classify typical roof edges:
<table cellspacing="10">
<tr><td><span class="cga_opparam">eave</span></td><td>Horizontal border edges on the bottom of the roof. The edges are always oriented anti-clockwise around the original face.</td></tr>
<tr><td><span class="cga_opparam">hip</span></td><td>Inside edges connected to at least one eave edge. Hip edges are always oriented upwards, i.e. the ending point has larger y-coordinate than the starting point.</td></tr>
<tr><td><span class="cga_opparam">valley</span></td><td>Inside edges where the two connected faces form a concavity. Valley edges are always oriented upwards, i.e. the ending point has larger y-coordinate than the starting point.</td></tr>
<tr><td><span class="cga_opparam">ridge</span></td><td>Inside edges which are not <span class="cga_opparam">hip</span> or <span class="cga_opparam">valley</span>. Ridge edges are always oriented upwards, i.e. the ending point has larger y-coordinate than the starting point.</td></tr>
</table>
</p>

<p>These selectors can only be applied on edge component splits!</p>

<p>The figure below shows a few examples.
<center><img src="images/comp_split_roof_edges.png" alt="Roof Edge Selectors"></center>
</p>

<a name="streetSelectors"></a><h3>Street Selectors</h3>

<p>Components adjacent to a street can be selected with the <span class="codelight">street.front</span> selector, rear components can be selected with the <span class="codelight">street.back</span> selector, and components in between front and back can be selected with the <span class="codelight">street.left</span> and <span class="codelight">street.right</span> selectors. <span class="codelight">street.side</span> combines left and right components.</p>

<table>
<tr>	
	<td>
	<img src="images/street_selectors.png" alt="Street Selectors" width="165"> 
	</td>
	<td>
	<img src="images/street_selectors_multi.png" alt="Street Selectors (many of them)" width="557">
	</td>
</tr>
</table>
<center><em>The picture above shows some examples for the <span class="codelight">street.xxx</span> selectors.</em><br></center>

<p>These selectors depend on the availability of the streetWidth attribute map; see <a href="https://doc.arcgis.com/en/cityengine/latest/help/help-layers-block-parameters.htm#ESRI_SECTION2_5A91A7408D2240929B5EDA53D6B21FA3" target="_blank">Auto-generated street width attributes</a>. If the attribute is not available, component selection falls back to the <span class="codelight">object.xxx</span> selectors.</p>

<h2>Related</h2>

<ul>
	<li><a class="normw" href="op_i.html">i (insert) operation</a></li>
	<li><a class="normw" href="op_trim.html">trim operation</a></li>
	<li><a class="normw" href="func_comp.html">comp function</a></li>
	<li><a class="normw" href="attr_comp.html">comp attribute</a></li>
	<li><a class="normw" href="attr_pivot.html">pivot attribute</a></li>
	<li><a class="normw" href="attr_scope.html">scope attribute</a></li>
	<li><a class="normw" href="attr_trim.html">trim attribute</a></li>
	<li><a class="normw" href="func_assetNamingInfo.html">assetNamingInfo / assetNamingInfos function</a></li>
	<li><a class="normw" href="func_geometry.html#groups">geometry.groups function</a></li>
	<li><a class="normw" href="func_geometry.html#materials">geometry.materials function</a></li>
</ul>

<h2>Examples</h2>

<h3 id="faceDetails">Facade Selection / Face Split Details</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br/><img src="images/comp-facade-a.png" alt="Facade selection a" width="298"/> </td>
	<td><i>Let us split the mass model of a building into the main facade and a number of side facades.</i><em><i><br>Note the orientation of the pivot (the annotated axes).</i><br></em></td>
</tr>
<tr>
	<td class="twocol_l"><br/><img src="images/comp-facade-b.png" alt="Facade selection b" width="298" height="140"/></td>
	<td><pre class="code3">
Building -->	
   comp(f) { 
      front : color("#ff0000") Main. | 
      side  : color("#0000ff") Side. 
   }
   </pre><em></em></td>
</tr>
<tr>
	<td class="twocol_l"><br/><img src="images/comp-facade-c.png" alt="Facade selection c" width="298"/></td>
	<td><em>Each face is now the geometry of a new shape; the new shapes' scopes and pivots depend on the faces' orientation. The x-axis points along the first edge and the z-axis points along the face normal. The scope's z-dimension is zero.</em></td>
</tr>
</table>

<h3>Selectors 1: Quadrant-based</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br/><img src="images/comp-selectors1.png" alt="comp split selectors 1" width="298"/></td>
	<td><pre class="code3">
Sphere -->
   comp(f) {
      top:    color("#0000ff") X. |	
      bottom: color("#ffff00") X. |	
      front:  color("#ff0000") X. | 
      back:   color("#ff00ff") X. |
      left:   color("#00ffff") X. |
      right:  color("#00ff00") X.	
   }
   </pre><em>Selectors are demonstrated by using them to color the faces of a spherical geometry. The selection is relative to the local coordinate system (the shown scope).</em></td>
</tr>
</table>
                              
<h3>Selectors 2: Angle to y-axis based</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br/><img src="images/comp-selectors2.png" alt="comp split selectors 2" width="298"/></td>
	<td><pre class="code3">
Sphere -->
      comp(f) {
      horizontal: color("#0000ff") X. |	
      aslant:     color("#ff0000") X. | 
      vertical:   color("#ffff00") X. |	
      nutant:     color("#ff00ff") X. 
   }
	</pre><em>Note the horizontal areas (blue) on the sphere's poles.</em></td>
</tr>
</table>
                              
<h3>Logical selection expressions</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br/><img src="images/comp_selExpr_1.png" alt="comp_selExpr_1" width="298"/></td>
	<td><pre class="code3">
Sphere --> comp(f) { top || front = X. }
	</pre><em>Static selectors can be used in a logical selector expression. Here both the top and front faces are combined into a single shape. </em></td>
<tr>
<td class="twocol_l"><br/><img src="images/comp_selExpr_2.png" alt="comp_selExpr_2" width="298"/></td>
	<td><pre class="code3">

Triangle -->
   comp(f) { geometry.area() > 1 && !inside : X. }
   </pre><em>Here, only faces with a surface area greater than 1 and that are not inside are selected. </em></td>
</tr>
<td class="twocol_l"><br/><img src="images/comp_selExpr_3.png" alt="comp_selExpr_3" width="298"/></td>
	<td><pre class="code3">

mySelectorFunc = 
    geometry.isOriented(top) || geometry.nVertices==3

Sphere -->
   comp(f) { mySelectorFunc : X. }
   </pre><em>Here, a custom function is used to select the top faces and all faces with exactly 3 vertices. </em></td>
</tr>
</table>
                              
<h3>Index-based Selection</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br/><img src="images/comp-index-selectors-a.png" alt="Index selectors a" width="298"/></td>
	<td><em>A mesh can also be disassembled into its components by addressing them directly by their index.<br>The indexing scheme is inherently encoded in the model itself!</em></td>
</tr>
<tr>
<td class="twocol_l"><br/><img src="images/comp-index-selectors-b.png" alt="Index selectors b" width="298"/></td>
	<td><pre class="code3">
Tube -->
   comp(f) { 
      0 : X. | 
      2 : X. | 
      4 : X. 
   }
   </pre><em>Here, only faces 0, 2 and 4 of the cylinder are selected.</em></td>
</tr>
</table>
                              
<a name="trimExamples"></a><h3>Trim Planes</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br/><img src="images/comp-trimplanes-a.png" alt="Trim Planes a" width="298"/></td>
	<td><pre class="code3">
Start -->
   s(10,10,10)
   primitiveCube()
   comp(f) { 5 : X. }
	</pre><em>At shared edges, trim planes (green) are inserted.</em></td>
</tr>
<tr>
	<td class="twocol_l"><br/><img src="images/comp-trimplanes-b.png" alt="Trim Planes b" width="298"/></td>
	<td><pre class="code3">
X -->
   s(15,'1, 2)
   center(xyz)
   primitiveCube()
	</pre><em>Inserted geometry is cut with the trim planes.</em></td>
</tr>
<tr>
	<td class="twocol_l"><br/><img src="images/comp-trimplanes-c.png" alt="Trim Planes c" width="298"/></td>
	<td><pre class="code3">
Start -->
   s(10,10,10)
   primitiveCube()
   set(trim.horizontal, true)
   comp(f) { 5 : X. }
	</pre><em><strong>By default, horizontal trim planes are off.</strong> Enabling them before inserting the geometry gives a different result.</em></td>
</tr>
</table>

<h3>The Operator</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l" style="width:298px" ><br/><img src="images/comp_operator-a.png" alt="Comp Operator :" /></td>
	<td><pre class="code3">
            
            
            
Lot -->
   extrude(20)
   comp(f) { side : Sides. }
	</pre><br><p><em>Using the ":" operator results in a new shape for each component selected by the selector.<br>In the example above, a shape is created for each side of the extruded geometry. Therefore, the Lot Shape has five successors (one for each side). Each successor shape has its pivot and scope set up differently.</em></p></td>

</tr>          
<tr>
	<td class="twocol_l" style="width:298px"><br/><img src="images/comp_operator-b.png" alt="Comp Operator :" /></td>
	<td><pre class="code3">
            
            
            
Lot -->
   extrude(20)
   comp(f) { side = Sides. }
	</pre><br><p><em>In contrast, using the "=" operator results in exactly one new shape for all component selected by the selector.<br>In the example above, one shape is created for all five sides of the extruded geometry. Thje new shape's geometry contains all five faces, and the pivot and scope are set up relative to the first selected face.</em></p></td>
</table>

<h3><em>Border</em> and <em>Inside</em> Selectors</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br/><img src="images/comp-border-a.png" alt="Border Selector Initial Shape" width="298"/></td>
	<td><br><br><br><p><em>The picture on the left shows the initial shape. It is a subdivided plane, consisting of a number of faces.</em></p></td>
</tr>  
<tr>
	<td class="twocol_l"><br/><img src="images/comp-border-b.png" alt="Border Selector Face Split" width="298"/></td>
	<td><pre class="code3">
Init -->
   comp(f) { border : FBorder | inside : FInside  }
   
FBorder -->
   color("#ff0000")
	
FInside -->
   color("#00ff00")
	</pre><p><em>The example selects the border and inside faces and colors them.</em></p></td>
</tr>          
<tr>
	<td class="twocol_l"><br/><img src="images/comp-border-c.png" alt="Border Selector Edge Split" width="298"/></td>
	<td><pre class="code3">
Init-->
   comp(e) { border : EBorder | inside : EInside  }

EBorder --> s('1, 0.05, 0.05) t(0, '-0.5, 0)
            color("#ff0000") primitiveCube()
	
EInside --> s('1, 0.01, 0.01) t(0, '-0.5, 0)
            color("#00ff00") primitiveCube()
	</pre><p><em>Here, there border and inside edges are selected and colored cubes are inserted.</em></p></td>
</tr>          
<tr>
	<td class="twocol_l"><br/><img src="images/comp-border-d.png" alt="Border Selector Vertex Split" width="298"/></td>
	<td><pre class="code3">
            
Init -->
   comp(v) { border : VBorder | inside : VInside  }
   
VBorder --> s(0.05, 0.05, 0.05) t(-0.025, -0.025, -0.025)
            color("#ff0000") primitiveCube()
   
VInside --> s(0.05, 0.05, 0.05) t(-0.025, -0.025, -0.025)
            color("#00ff00") primitiveCube()
	</pre><p><em>Finally, the border and inside vertices are used to insert colored cubes.</em></p></td>
</tr>          
</table>

<h3 id="isTagged"><em>isTagged</em> Selector</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br/><img src="images/comp-isTagged-faces.png" alt="Comp isTagged Faces" width="298"/></td>
	<td><pre class="code3">
Init --> envelope(normal,4, 0,45, 3,45, 2.5,50, 2,50)
         ShowEnvelopeAutoTags
         
ShowEnvelopeAutoTags -->
    comp(f) { isTagged("envelope.bottom")     : Blue 
            | isTagged("envelope.side.base")  : Yellow
            | isTagged("envelope.side.slope") : Orange
            | isTagged("envelope.side.inner") : Red
            | isTagged("envelope.top")        : Green } 
	</pre><em>This example colors the face components based on the face tags applied by the <a class="cga_op" href="op_envelope.html">envelope</a> operation.</em></p></td></td>
</tr>  
<tr>
	<td class="twocol_l"><br/><img src="images/comp-isTagged-faces-2.png" alt="Comp isTagged Faces 2" width="298"/></td>
	<td><pre class="code3">


Init --> envelope(normal,4, 0,45, 3,45, 2.5,50, 2,50)
         comp(f) { isTagged("envelope.side") : Yellow }
	</pre><p><em>Here, the <a href="cga_componentTags.html#tagQueries" class="xref">tag query</a> <span class="codelight">"envelope.side"</span> is used to select and color all base, slope and inner side faces at once.</em></p></td>
</tr>  
<tr>
	<td class="twocol_l"><br/><img src="images/comp-isTagged-edges.png" alt="Comp isTagged Edges" width="298"/></td>
	<td><pre class="code3">


Init --> envelope(normal,4, 0,45, 3,45, 2.5,50, 2,50)
         comp(e) { isTagged("envelope.top") : Edge }
         
Edge --> s('1, 0.5, 0.5) center(yz)
         color("#09de1f") primitiveCube()
	</pre><p><em>Here, the edges of the face tagged <span class="codelight">"envelope.top"</span> are selected and colored cubes are inserted.</p>.</em></p></td>
</tr>          
<tr>
	<td class="twocol_l"><br/><img src="images/comp-isTagged-vertices.png" alt="Comp isTagged Vertices" width="298"/></td>
	<td><pre class="code3">


Init --> envelope(normal,4, 0,45, 3,45, 2.5,50, 2,50)
         comp(v) { isTagged("envelope.top") : Edge }
         
Edge --> s(0.5, 0.5, 0.5) center(xyz)
         color("#09de1f") primitiveSphere(8,6)
	</pre><p><em>Here, the vertices of the face tagged <span class="codelight">"envelope.top"</span> are selected and colored spheres are inserted.</em></p></td>
</tr>  
</table>
<p class="notes">By default, edges can be selected based on the tags of adjacent faces, while vertices can be selected based on the tags of adjacent faces and edges. However, to select faces based on the tags of their edges or vertices, the <span class="cga_opparam">subcomponent</span> parameter must be provided, as demonstrated in the <a href="op_comp.html#isTagged_advanced" class="xref">section below</a>.</p>
<h3 id="isTagged_advanced">Advanced Tag Selection</h3>
<table>        
<tr>
	<td class="twocol_l"><br/><img src="images/comp-isTagged-subcomp1.png" alt="Comp isTagged With Subcomp1" width="298"/></td>
	<td><pre class="code3">
            
Init --> envelope(normal,4, 0,45, 3,45, 2.5,50, 2,50)
         comp(f) { isTagged("envelope.bottom", e) 
            : ShowEnvelopeAutoTags }
	</pre><p><em>By using the <span class="codelight">e</span> subcomponent selector, all faces that share an edge with a face tagged <span class="codelight">"envelope.bottom"</span> or have an edge tagged as such, are selected. <br> <br> Note that the face tagged <span class="codelight">"envelope.bottom"</span> (blue) is selected as well.</em></p></td>
</tr> 
<tr>
	<td class="twocol_l"><br/><img src="images/comp-isTagged-subcomp2.png" alt="BComp isTagged With Subcomp2" width="298"/></td>
	<td><pre class="code3">
            
Init --> envelope(normal,4, 0,45, 3,45, 2.5,50, 2,50)
         comp(f) { isTagged("envelope.bottom", e) &&
                   isTagged("envelope.side.slope") 
            : ShowEnvelopeAutoTags }
	</pre><p><em>This example selects all slope faces that are edge-adjacent to the bottom face.</em></p></td>
</tr>
<tr>
	<td class="twocol_l"><br/><img src="images/comp-isTagged-subcomp3.png" alt="BComp isTagged With Subcomp2" width="298"/></td>
	<td><pre class="code3">
            
Init --> envelope(normal,4, 0,45, 3,45, 2.5,50, 2,50)
         comp(e) { isTagged("envelope.bottom", v)
            : Edge }
            
Edge --> s('1, 0.5, 0.5) center(yz)
         color("#09de1f") primitiveCube()
	</pre><p><em>This example selects all edges that share a vertex with the bottom face and inserts colored cubes.</em></p></td>
</tr>           
</table>

<h3 id="edgeDetails">Edge Split Details</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br/><img src="images/comp-edges.png" alt="Edge Split" width="298"/></td>
	<td><pre class="code3">
	
Lot --> extrude(3) 
        comp(e) { all : primitiveCube() s('1, 0.25, 1) X. }
	</pre><p><em>A building mass model is split into its edges, and the built-in cube model is inserted into each edge shape. The <span class="codelight">pivot</span> of the new shape is positioned at one of the edge's vertices, and the alignment is as follows: the x-axis is parallel to the edge, the z-axis is the average of the neighboring face normals and the y-axis is normal to the two former ones. The <span class="codelight">scope</span> has zero translation and rotation, and the sizes are (edge-length, 0, 0).</em></p></td>
</tr>
<tr>
	<td class="twocol_l"><br/><img src="images/comp-face-edges.png" alt="Edge Split" width="298"/></td>
	<td><pre class="code3">
	
	
	
Lot --> extrude(3) 
        comp(fe) { all : primitiveCube() s('1, 0.25, 1) X. }
	</pre><p><em>A split into face edges creates more components, for each face the edges are considered separately. Edges are oriented wrt. face orientations. The <span class="codelight">pivot</span> is now set to the edge's start vertex and the x-axis points in face orientation, the z-axis is pointing out of the face orthogonally to the edge and the face normal.</em></p></td>
</tr>          

</table>

<h3 id="vertexDetails">Vertex Split Details</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br/><img src="images/comp-vertices.png" alt="Edge Split" width="298"/></td>
	<td><pre class="code3">
Lot -->
   extrude(10) 
   MassModel
   comp(v) { all : VShapes. }
	</pre><p><em>A building mass model is split into its vertices.<br>The <span class="codelight">pivot</span> of the new shape (the VShapes in the rule above) is set to the vertex position, and the alignment is as follows: the z-axis is the average of the neighboring face normals and the x- and y-axes are chosen such that they are all normal to each other.<br>The <span class="codelight">scope</span> has zero translation, rotation and size.</em></p></td>
</tr>          
</table>

<h3>Group Split Details</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br/><img src="images/comp-group.png" alt="Group Split" height="200"/></td>
	<td><pre class="code3">



Lot -->
   i("Orange_Tree.obj") 
   comp(g) { findFirst(geometry.materials,"Bark") : Trunk.
           | all = set(material.opacity, 0.2) Foliage. }
	</pre><p><em>A tree model is split into its groups.</em></p></td>
</tr>          
</table>

<h3>Material Split Details</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br/><img src="images/comp-material.png" alt="Material Split" height="200"/></td>
	<td><pre class="code3">



Lot -->
   i("Orange_Tree.obj") 
   comp(m) { findFirst(geometry.materials,"Foliage") : Oranges. 
           | findFirst(geometry.materials,"Bark")    : Trunk. }
	</pre><p><em>A tree model is split into its materials. In this case groups and materials are the same.</em></p></td>
</tr>
</table>
                              
<p class="foot">Copyright &copy;2008-2023 Esri R&amp;D Center Zurich. All rights reserved.</p>				  

</div>
</body>
</html>
<html>

<head>
    <title>Occlusion Queries</title>
    <link rel="stylesheet" href="../manual_style.css" type="text/css">
</head>

<body>
<div class="content">

<!-- HEADER (use only on bookchapters) -->

<table summary="" class="header">
	<tr>
		<td align="left" class="helphead_l"><a href="../toc.html"><div class="helplink">&nbsp;</div></a></td>
		<td align="right" class="helphead_r"></td>
	</tr>
</table>

<!-- CONTENT -->

<h1>inside / overlaps / touches (occlusion queries)</h1>
	
<h2>Synopsis</h2>

<p class="code2">bool inside()</p>
<p class="code2">bool overlaps()</p>
<p class="code2">bool touches()</p>
<br>
<p class="code2">bool inside(<span class="cga_opparam">target-selector</span>)</p>
<p class="code2">bool overlaps(<span class="cga_opparam">target-selector</span>)</p>
<p class="code2">bool touches(<span class="cga_opparam">target-selector</span>)</p>
<br>
<p class="code2">bool inside(<span class="cga_opparam">target-selector</span>, <span class="cga_opparam">label</span>)</p>
<p class="code2">bool overlaps(<span class="cga_opparam">target-selector</span>, <span class="cga_opparam">label</span>)</p>
<p class="code2">bool touches(<span class="cga_opparam">target-selector</span>, <span class="cga_opparam">label</span>)</p>

<h2>Parameters</h2>

<ul>
	<li><span class="cga_opparam">target-selector</span> (keyword)<br>
	Target selector for the query:
	<ul>
		<li><span class="codelight">intra</span>: Checks against occluder shapes in the same shape tree (i.e. from the same inital shape).</li>
		<li><span class="codelight">inter</span>: Checks against occluder shapes in other shape trees (i.e. generated by other initial shapes in the neighborhood).</li>
		<li><span class="codelight">all</span>: Checks both <span class="codelight">intra</span> and <span class="codelight">inter</span>.</li>
	</ul>
	If no selector is given, <span class="codelight">all</span> is used.</li>
	<li><span class="cga_opparam">label</span> (string)<br>
	Given a label identifier the occlusion query is performed only on occluder shapes that match the requested <a href="op_label.html">label</a>. An empty label will behave as an unlabeled occlusion query.</li>
</ul>
		
<h2>Returns</h2>

<p><span class="cga_keyword">true</span> if the geometry of the current shape lies fully inside, overlaps, or touches the <em>closed</em> geometry of another shape respectively, otherwise <span class="cga_keyword">false</span>.</p>

<p class="info">
An occlusion query tests for intersections between shapes. There are three different boolean functions available to examine the spatial context of the geometry of the current shape:
<ul>
	<li><span class="code_std">inside()</span> returns <span class="cga_keyword">true</span> if the geometry of the current shape lies <em>completely inside</em> or <em>completely on the surface</em> of one of the closed geometries specified by <span class="cga_opparam">target-selector</span> and <span class="cga_opparam">label</span>.</li>
	<li><span class="code_std">overlaps()</span> returns <span class="cga_keyword">true</span> if the geometry of the current shape lies <em>partly inside</em> of one of the closed geometries specified by <span class="cga_opparam">target-selector</span> and <span class="cga_opparam">label</span> (or vice-versa).</li>
	<li><span class="code_std">touches()</span> returns <span class="cga_keyword">true</span> if the geometry of the current shape <em>overlaps</em> or has a <em>planar contact</em> with one of the closed geometries specified by <span class="cga_opparam">target-selector</span> and <span class="cga_opparam">label</span>.</li>
</ul></p>
<p class="piccaptioncentered"><img src="images/occlusiontests.png"><br>A visual definition of the three occlusion functions (in white: occluder shapes; in red: query shapes).</p>

<p class="notes">In any case, tests are only performed against geometries which form a closed surface (i.e. a waterproof mesh which has no boundary edges).</p>

<p class="notes"><a class="normw" href="cga_context.html">Learn more</a> about important characteristics for occlusion queries in conditions and inter occlusion.</p>

<h3>Unlabeled occlusion queries</h3>

<a name="nolabel"></a>
<p>In case no <span class="cga_opparam">label</span> is given or the <span class="cga_opparam">label</span> is empty, the geometry of the current shape is tested against a practical selection of closed occluder geometries that are automatically generated with the ruleset:
<ul>
	<li>Leaf shapes.</li>
	<li>Shapes on which a <a href="op_comp.html">component split</a> or <a href="op_offset.html">offset</a> has been applied. These operations represent typically the transition from mass to surface. Furthermore, these operations are typically applied on simple geometries which can be tested efficiently against occlusion.</li>
	<li>Any <a href="op_label.html">labeled</a> occluder shape.</li>
</ul></p>

<h3>Intra occlusion</h3>

<p>Intra occlusion queries are only performed against geometries that are neither a parent/ancestor nor a child/descendant of the query shape since they most likely occlude the current shape due to the top-down grammar modeling approach.</li>

<h2>Related</h2>
    
<ul>
	<li><a class="normw" href="cga_context.html">Context queries</a></li>
	<li><a class="normw" href="op_label.html">label operation</a></li>
	<li><a class="normw" href="op_comp.html">comp operation</a></li>
	<li><a class="normw" href="op_offset.html">offset operation</a></li>
</ul>

<h2>Examples</h2>

<h3>Intra occlusion</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br>
	<img src="images/occlusion-intra.png" alt="intra occlusion" width="298"></td>
	<td><pre class="code3">
	
	
Init --> extrude(15)
         split(x) { ~5 : Step }*
		
Step --> s('1, '0.7 * (split.index + 1), '1)
         comp(f) { side : Facade | top : X. }
	
Facade --> split(y) { 4 : Tile }*	

Tile --> case touches(intra) : color(1,0,0) X.
         else : X.
	</pre>
	<em>This example demonstrates the result of the <span class="cga_keyword">touches()</span> occlusion query on shapes of one shape tree (intra occlusion). As there is no label given, the occlusion query will test against automatically generated occluder shapes: the closed geometries on which the component split is applied. Note that each occlusion query does not consider predecessor occluder shapes, namely the component split volume that a Tile originates from. The leaf shapes constructed in the component split and in the conditional <span class="cga_keyword">false</span> case are not considered as they do not form a closed geometry.</em></td>
</tr>
</table>

<h3>Inter occlusion</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br>
	<img src="images/occlusion-inter.png" alt="inter occlusion" width="298"></td>
	<td><pre class="code3">
House --> extrude(5+rand(20))
          comp(f) { side : Facade | top : Roof }

Roof --> roofGable(20) color(1,0,0)

Facade --> split(y) { ~5 : split(x) { ~5 : Tile }* }*

Tile --> case inside(inter) : NIL
         case touches(inter) : Wall.
         else : setback(1) { all : Wall. | remainder : NIL }
	</pre>
	<em>In this example the <span class="cga_keyword">House</span> rule is applied to two neighboring initial shapes (inter occlusion). Closed occluder shapes are automatically created: Blocks (component split) and roofs (leaf shapes). Further leaf shapes are not considered as they do not form a closed surface. The <span class="cga_keyword">inside()</span> query prevents the insertion of tiles that are not visible because they are occluded by neighboring blocks or roofs. The <span class="cga_keyword">touches()</span> query prevents the creation of windows that occlude neighboring blocks or roofs and inserts a wall instead.</em></td>
</tr>
</table>

<h3>Labels</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br>
	<img src="images/occlusion-labels-1.png" alt="labels 1" width="298"></td>
	<td><pre class="code3">
Field --> Ground
          scatter(surface, rand(500), uniform) { Place }
		  
Ground --> color(0,0.5,0)

Place --> 1% : PlaceHouse else : PlaceRandomTree

PlaceHouse --> r(0,rand(180),0)
               primitiveQuad(10+rand(10), 10+rand(10))
               House
			   
PlaceTree --> i(fileRandom("/assets/*.obj"))

Tile --> case inside(intra) : NIL
         case touches(intra) : Wall.
         else : setback(1) { all : Wall. | remainder : NIL } 
	</pre>
	<em>In this example the Field rule is applied to one rectangular initial shape (intra occlusion). Beside houses, also random closed tree assets are scattered on the shape. Additional occluder shapes are automatically created for each tree asset (leaf shapes). We can change the <span class="cga_opparam">target-selector</span> to <span class="codelight">intra</span> in the Tile rule of the house.</em></td>
</tr>
<tr>
	<td class="twocol_l"><br>
	<img src="images/occlusion-labels-2.png" alt="labels 2" width="298"></td>
	<td><pre class="code3">
	
	
PlaceTree --> i(fileRandom("/assets/*.obj"))
              CheckOverlap

CheckOverlap --> case overlaps(intra) : NIL
                 else : Tree.
	</pre>
	<em>Here <span class="cga_keyword">overlaps()</span> is used to avoid overlapping tree assets. Note how all mutual overlapping trees are removed although it might be enough to remove a subset of tree assets. Also note that some windows do not appear because they touch occluder shapes generated by the inserted tree assets. This example illustrates how occlusion queries test against occluder shapes created in the conditional <span class="cga_keyword">false</span> case which inserts all tree assets regardless of occlusion.</em></td>
</tr>
<tr>
	<td class="twocol_l"><br>
	<img src="images/occlusion-labels-3.png" alt="labels 3" width="298"></td>
	<td><pre class="code3">
	
	
House --> extrude(5+rand(20))
          label("block")
          comp(f) { side : Facade | top : Roof }

Tile --> case inside(all, "block") : NIL
         case touches(all, "block") : Wall.
         else : setback(1) { all : Wall. | remainder :  Window }
	</pre>
	<em>In this example the house blocks are labeled <span class="codelight">"block"</span> using the <span class="cga_keyword">label()</span> operation. This label is used in the occlusion queries in the <span class="cga_keyword">Tile</span> rule. Now, windows will only be tested against occluder shapes that match the requested label and not against the automatically generated occluder shapes of the tree assets.</em></td>
</tr>
<tr>
	<td class="twocol_l"><br>
	<img src="images/occlusion-labels-4.png" alt="labels 4" width="298"></td>
	<td><pre class="code3">
	
	
	
	
CheckOverlap --> case overlaps(intra, "block") : NIL
                 else : Tree.
	</pre>
	<em>The label can further be used in the occlusion query in the <span class="cga_keyword">CheckOverlap</span> rule of the trees. As a consequence, the tree assets are checked against the house blocks but not against each other.</em></td>
</tr>
</table>

<h3>Concrete example</h3>

Let us look at a concrete example. The picture below shows a building model. First the rule generates an U-shaped mass model by using the subdivision split operation. As a consequence, the geometries of the side wings touch the geometry of the main block and unrealistically intersected windows are generated. 
<p class="piccaptioncentered"><img src="images/occlusion-modern-building.png">
<br>
Left: No occlusion queries are used. Center: Occluded windows are colored red. Right: Occluded windows are dropped.</p>
<p>The rule which constructs the windows looks like this:
<pre class="code3">
WindowOpening --> Sill s('1,'1,windowSetback) t(0,0,'-1) [ i(openbox) Wall ] Window
</pre></p>
<p>The rule first invokes the generation of a window sill, then sets the size of the scope to the depth of the window setback and translates the scope accordingly. Afterwards the openbox asset is inserted to model the wall on the side of the window opening. Finally the actual Window generation is invoked.</p>
<p>To make this rule react to occlusions, we add a <span class="cga_keyword">touches()</span> condition:
<pre class="code3">
WindowOpening-->
  case touches(intra) : Wall
  else : Sill s('1,'1,windowSetback) t(0,0,'-1) [ i(openbox) Wall ] Window
</pre></p>
<p>Now, in case the geometry of the WindowOpening shape, which is a rectangular polygon generated by the typical facade split rules, touches another shape's geometry, the rule just invokes the Wall rule and does not create a window. Otherwise the rule is applied as before. The above figure shows the resulting building model on the right.</p>

<!-- FOOTER -->
<p class="foot">Copyright &copy;2008-2017 Esri R&amp;D Center Zurich. All rights reserved.</p>			  

<!-- END CENTERED CONTENT -->

</div>
</body>
</html>
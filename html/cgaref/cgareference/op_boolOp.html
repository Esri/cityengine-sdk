<html>

<head>
	<title>Boolean 3D operations</title>
	<link rel="stylesheet" href="../manual_style.css" type="text/css" />
</head>

<body>
<div class="content">

<table summary="" class="header">
	<tr>
		<td align="left" class="helphead_l"><a href="../toc.html"><div class="helplink">&nbsp;</div></a></td>
		<td align="right" class="helphead_r"></td>
	</tr>
</table>

<h1>Boolean 3D operations</h1>

<h2>Syntax</h2>

<p class="code2"><span class="cga_op">union</span> <span class="cga_opparam">B-Rule</span></p>
<p class="code2"><span class="cga_op">union</span>(<span class="cga_opparam">swapMode</span>) <span class="cga_opparam">B-Rule</span></p>

<p class="code2"><span class="cga_op">subtract</span> <span class="cga_opparam">B-Rule</span></p>
<p class="code2"><span class="cga_op">subtract</span>(<span class="cga_opparam">swapMode</span>) <span class="cga_opparam">B-Rule</span></p>

<p class="code2"><span class="cga_op">intersect</span> <span class="cga_opparam">B-Rule</span></p>
<p class="code2"><span class="cga_op">intersect</span>(<span class="cga_opparam">swapMode</span>) <span class="cga_opparam">B-Rule</span></p>


<h2>Parameters</h2>

<ul>
    <li><span class="cga_opparam">swapMode</span> (selector)
    <table cellspacing="5">
		<tr><td width="20%"><span class="codelight">noSwap</span></td><td>Default. Operand A (current shape) is the target.</td></tr>
		<tr><td width="20%"><span class="codelight">swap</span></td><td>Operand B (<span class="codelight">B-Rule</span>) is the target.</td></tr>
	</table>
	</li>
	<li><span class="cga_opparam">B-Rule</span>
	<br>A rule or sequence of operations that defines operand B using inlined derivation:  
	<table cellspacing="5">
		<tr><td width="20%"><span class="codelight">identifier</span></td><td>Name of a rule.</td></tr>
		<tr><td width="20%"><span class="codelight">{ operations }</span></td><td>A sequence of shape operations in curly brackets.</td></tr>
		
	</table>
	</li>
</ul>

<h2>Description</h2>
<p>The <span class="codelight">union</span>, <span class="codelight">intersect</span>, and <span class="codelight">subtract</span> operations perform the specified Boolean 3D operations between the current shape (operand A) 
and the result of the inlined <span class="codelight">B-Rule</span> (operand B). 
The <span class="codelight">swapMode</span> parameter determines the target shape, which, for example, enables subtracting operand A from operand B instead. 
It also determines the resulting shape attributes and specifies which material is used for overlapping geometry.
Operand B is constructed analogous to using <span class="codelight">inline(unify) B-Rule</span>, meaning that the shapes resulting from the derivation of <span class="codelight">B-Rule</span> are first merged using the union operation.
<br>In case the operands have conflicting material attributes, their materials are first written to the geometry, ensuring that all material properties are preserved.
</p>

<p class="notes">The operations can handle both 3D and 2D inputs. When all input vertices lie on the same plane, a Boolean 2D operation is performed instead.</p>
<p class="notes">In general, Boolean 3D operations are only defined for closed watertight meshes, as the result is determined by local inside/outside tests around the intersection segments. When using open operands, the result depends on where the intersection happens - see <a href="op_boolOp.html#openclosed">examples</a>.</p>
<h3><a name="componentTags"></a>Component tags</h3>
The operations automatically apply semantic <a href="cga_componentTags.html">component tags</a> to the resulting face components:

<p class="piccaptioncentered"><img src="images/autotag-boolOps.png">

<table summary="" class="twocol">
<tr>
    <td>
		
		<table cellspacing="5">
			<tr><td width="25%"><span class="codelight">"bool.A"</span></td><td>Blue: faces from operand A.</td></tr>
			<tr><td><span class="codelight">"bool.B"</span></td><td>Green: faces from operand B.</td></tr>
		</table>
	</td>
	<td class="twocol_l">
<pre class="code3">
Left   --> extrude(1) 
           union Sphere
           comp(f) { isTagged("bool.A"): Blue 
                   | isTagged("bool.B"): Green }
Sphere --> t(0.3, 0.3, 0.3) primitiveSphere()

Middle --> ... subtract Sphere ...
Right  --> ... intersect Sphere ...</pre> </td></tr>
</table>
<p class="notes">Both <span class="codelight">"bool.A"</span> and <span class="codelight">"bool.B"</span> are applied to overlapping faces (2D case).</p>
</p>
For more information on working with component tags, refer to:
	<ul>
		<li><a href="cga_componentTags.html#autoTags">Auto-tags</a></li>
		<li><a href="cga_componentTags.html#tagPropagation">Tag propagation</a></li> 
	</ul>

<h2>Related</h2>
<ul>
	<li><a class="normw" href="op_inline.html">Rule Inlining</a></li>
	<li><a class="normw" href="op_tag.html">tag operation</a></li>
</ul>

<h2><a name="examples"></a>Examples</h2>

<h3>Swap Mode</h3>

<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_swapMode_subtract.png" alt="SwapMode subtract" width="298"/></td>
	<td>
	<pre class="code3">

Left -->
    color("#0399F5") // blue
    primitiveCube
    subtract Cylinder
    
Right --> 
    color("#0399F5") // blue
    primitiveCube
    subtract(swap) Cylinder
 
Cylinder -->
    color("#09DE1F") // green
    t(3,3,3)
    primitiveCylinder</pre>
	<em>The <span class="codelight">swapMode</span> parameter determines which shape is subtracted from the other. 
	</em>
	</td>
</tr>
</table>

<br><br>

<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_swapMode_material.png" alt="SwapMode material" width="298"/></td>
	<td>
	<pre class="code3">
Left -->
    color("#0399F5") // blue
    union Circle
    
Right --> 
    color("#0399F5") // blue
    union(swap) Circle
 
Circle -->
    color("#09DE1F") // green
    t(3,0,3)
    primitiveDisk</pre>
	<em>
	The <span class="codelight">swapMode</span> parameter determines the material of overlapping faces.
	</em>
	</td>
</tr>
</table>

<br><br>

<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_swapMode_attr.png" alt="SwapMode attribute" width="298"/></td>
	<td>
	<pre class="code3">
attr Height = 10

Left -->
    intersect Circle
    extrude(Height) // Height == 10
    
Right --> 
    intersect(swap) Circle
    extrude(Height) // Height == 1
 
Circle -->
    set(Height, 1)
    t(3,0,3)
    primitiveDisk</pre>
	<em>The <span class="codelight">swapMode</span> parameter determines the attributes of the resulting shape.</em>
	</td>
</tr>
</table>

<h3>B-Rule</h3>
<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_BRule_single_multiple.png" alt="B-Rule illustration single vs multiple shapes" width="298"/></td>
	<td>
	<pre class="code3">

Left -->
    color("#0399F5") // blue
    primitiveCube
    union {
        color("#09DE1F") // green
        t(1,1,1) B.
    }
    
Right --> 
    color("#0399F5") // blue
    primitiveCube
    union {
        color("#09DE1F") // green
        t(1,1,1) B0.
        t(1,1,1) B1.
        t(1,1,1) B2.
    }</pre>
	<em>Operand B is determined by <span class="codelight">B-Rule</span>, which can result in a single shape (<span class="codelight">Left</span>) or multiple shapes (<span class="codelight">Right</span>). In case of multiple shapes, they are first merged analogous to using <a class="normw" href="op_inline.html">inline(unify)</a>. 
	</em>
	</td>
</tr>
</table>

<br><br>

<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_BRule_multiple_nontouching.png" alt="B-Rule illustration non-touching" width="298"/></td>
	<td>
	<pre class="code3">
Init -->
    color("#0399F5") // blue
    primitiveCube
    union {
        color("#09DE1F") // green
        t(1,1,11) B0.
        t(1,1,1) B1.
        t(1,1,1) B2.
    }</pre>
	<em>
	In case <span class="codelight">B-Rule</span> results in multiple shapes, they are unified even if they do not intersect operand A.
	</em>
	</td>
</tr>
</table>

<h3>Mass Modeling</h3>

<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_halfSpheres_0_intersect.png" alt="Intersecting with Sphere" width="298"/></td>
	<td>
	<pre class="code3">

Init -->
    extrude(45)
    intersect Sphere

Sphere --> 
    s('1, '1, '2)
    center(z)
    t(0, '-0.2, 0)
    primitiveSphere
	</pre>
	<em>Step 1: The extruded initial shape (current shape, acting as operand A) is intersected with an inserted sphere (result of the rule <span class="codelight">Sphere</span>, acting as operand B). 
	</em>
	</td>
</tr>
</table>

<br><br>

<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_halfSpheres_1_unify.png" alt="Split and Unify" width="298"/></td>
	<td>
	<pre class="code3">
Init -->
    extrude(40)
    intersect Sphere
    inline(unify) split(y) { ~1: LowerHalf
                           | 20: UpperHalf }

LowerHalf --> X.
UpperHalf --> t(10,0,0) r(scopeCenter,0,7.2,0)
	</pre>
	<em>Step 2: The current shape is split into two parts. Using <a class="normw" href="op_inline.html">inline(unify)</a> the resulting shapes are unified (note the disappearing inner faces). 
	<br>
	Here we use <span class="codelight">inline(unify)</span> instead of the <span class="codelight">union</span> operation, because we do not want to add geometry to the current shape, but replace it with the union of the resulting shapes of the split operation (i.e., <span class="codelight">LowerHalf</span> and <span class="codelight">UpperHalf</span>).</em>
	</td>
</tr>
</table>

<br><br>

<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_halfSpheres_2_subtract.png" alt="Subtract a hole" width="298"/></td>
	<td>
	<pre class="code3">
Init -->
    extrude(40)
    intersect Sphere
    inline(unify) split(y) { ~1: LowerHalf
                           | 20: UpperHalf }
    subtract Hole
    
Hole -->
    s(16, 16, '1.2)
    center(z)
    t(30, 5, 0)
    rotateScope(-90, 0, 0)
    primitiveCylinder
	</pre>
	<em>Step 3: We continue refining the mass (current shape after Step 1 and 2, acting as operand A) by subtracting a cylinder (result of the rule <span class="codelight">Hole</span>, acting as operand B).</em>
	</td>
</tr>
</table>

<br><br>

<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_halfSpheres_3_tags.png" alt="Adding tags" width="298"/></td>
	<td>
	<pre class="code3">
Init -->
    extrude(40)
    tag("Envelope")
    intersect Sphere
    inline(unify) split(y) { ~1: LowerHalf
                           | 20: UpperHalf }
    subtract Hole
    comp(f) { isTagged("Envelope") && side: Blue
            | isTagged("Lower") && top    : Red
            | isTagged("Upper") && bottom : Orange
            | isTagged("Lower")           : Green
            | isTagged("Upper")           : Yellow
            | isTagged("Hole")            : Purple }

Sphere --> 
    s('1, '1, '2)
    center(z)
    t(0, '-0.2, 0)
    primitiveSphere

LowerHalf --> tag("Lower")
UpperHalf --> 
    t(10,0,0) 
    r(scopeCenter,0,7.2,0)
    tag("Upper")
              
Hole --> 
    s(16, 16, '1.2)
    center(z)
    t(30, 5, 0)
    rotateScope(-90, 0, 0)
    primitiveCylinder
    tag("Hole")

Blue -->   color("#0399F5")
Green -->  color("#09DE1F")
Yellow --> color("#FADB19")
Purple --> color("#8D09DE")
Red -->    color("#FF360A")
Orange --> color("#FA9100")
	</pre>
	<em>Adding tags: Using Boolean 3D operations, it is easy to create a mass model with complex surfaces. In this example, <a class="normw" href="op_tag.html">tags</a> are added in each step, which allows to assign the correct rule to the different surfaces at the end (illustrated here by different colors).  </em>
	</td>
</tr>
</table>

<h3>Boolean 3D and Auto-Tags</h3>

<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_with_autotags.png" alt="Boolean 3D with auto-tags" width="298"/></td>
	<td>
	<pre class="code3">
Init --> 
    extrude(40)
    subtract {
        t(20,-15,-15)
        rotate(rel,scope,15,12,25)	
    }
    SurfaceSplitter

SurfaceSplitter -->
    comp(f) { isTagged("extrude.top") 
                  && isTagged("bool.A"): Purple
            | isTagged("extrude.top") 
                  && isTagged("bool.B"): Green
            | isTagged("extrude.side")
                  && isTagged("bool.A"): Blue
            | isTagged("extrude.side") 
                  && isTagged("bool.B"): Yellow }
	</pre>
	<em>In this example, the initial shape is first extruded, which adds the <span class="codelight">"extrude"</span> <a class="normw" href="cga_componentTags.html#autoTags">auto-tags</a> to all faces. 
	Then, a translated and rotated copy of the shape is subtracted, which additionally adds the <span class="codelight">"bool"</span> auto-tags to the resulting faces. 
	Finally, these tags are used to extract the different surfaces and color them appropriately.  
	</em>
	</td>
</tr>
</table>

<h3>Layout Modeling</h3>

<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_layout_0.png" alt="Boolean 2D layout union" width="298"/></td>
	<td>
	<pre class="code3">
Init -->
    primitiveDisk(5)
    union FrontyardFootprint
    ShowBoolAutotags
    
FrontyardFootprint -->
    s(10,0,10)
    center(x)
    t(0,0,'-0.33)
    
ShowBoolAutotags -->
    comp(f) { isTagged("bool.A")
                  && isTagged("bool.B"): Yellow
            | isTagged("bool.A")       : Blue
            | isTagged("bool.B")       : Green }
	</pre>
	<em>
	Step 1: A pentagon (<span class="codelight">primitiveDisk(5)</span>) is inserted and then a union is done with a shrunk copy. The <span class="codelight">union</span> operation keeps all original edges, which means the resulting geometry consists of 3 faces, as shown in colors. 
	</em>
	</td>
</tr>
</table>

<br><br>

<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_layout_1.png" alt="Boolean 2D layout tags" width="298"/></td>
	<td>
	<pre class="code3">
Init -->
    primitiveDisk(5)
    union FrontyardFootprint
    deleteUV(0)
    inline(append) comp(f) { isTagged("bool.B")= B
                           | isTagged("bool.A")= A }
    cleanupGeometry(vertices, 0) // reconnect faces
    ShowTags
   
A --> tag("eHouse", edges)
B --> deleteTags("bool.A")
      cleanupGeometry(edges, 0) // merge faces
      tag("eFrontyard", edges)
      
ShowTags -->
    ShowBoolAutotags
    comp(e) { isTagged("eFrontyard") 
                  && isTagged("eHouse"): YellowEdge
           | isTagged("eHouse")        : BlueEdge
           | isTagged("eFrontyard")    : GreenEdge }
	</pre>
	<em>
	Step 2: The goal is to merge the yellow and green faces and tag the edges in preparation for Step 3. The <a class="normw" href="op_comp.html">comp</a> is used to modify the respective faces and then
	<a class="normw" href="op_inline.html">inlining</a> and <a class="normw" href="op_cleanupGeometry.html">cleanupGeometry</a> is used to merge the modified pieces back together. 
	<br><br>Note: In order to use <a class="normw" href="op_cleanupGeometry.html">cleanupGeometry</a> to merge the faces in rule <span class="codelight">B</span>, <a class="normw" href="op_deleteUV.html">deleteUV</a> is needed to remove the UV coordinates on the inserted assets, and <a class="normw" href="op_deleteTags.html">deleteTags</a> is required to remove <span class="codelight">"bool.A"</span>, which would otherwise prevent the process. 
	</em>
	</td>
</tr>
</table>

<br><br>

<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_layout_2.png" alt="Boolean 2D layout continued" width="298"/></td>
	<td>
	<pre class="code3">
Init -->
    primitiveDisk(5)
    union FrontyardFootprint
    deleteUV(0)
    inline(append) comp(f) { isTagged("bool.B")= B
                           | isTagged("bool.A")= A }
    cleanupGeometry(vertices, 0) // reconnect faces
    comp(f) { isTagged("bool.A"): House
            | isTagged("bool.B"): Frontyard }
            
House -->
    extrude(3)
    comp(f) { isTagged("eFrontyard"): Yellow
            | all                   : Blue }

Frontyard -->
    offset(-1)
    comp(f) { isTagged("eHouse"): Yellow
            | all               : Green } 
	</pre>
	<em>
		Step 3: The house footprint is <a class="normw" href="op_extrude.html">extruded</a> and the frontyard footprint is <a class="normw" href="op_offset.html">offset</a>. 
		The edge tags from Step 2 are automatically propagated to the new faces, allowing to distinguish the facades facing the frontyard and the offset borders touching the house. 
		
		<br><br>This information could be used in subsequent steps to model the entrance area.
	</em>
	</td>
</tr>
</table>

<h3><a name="openclosed"></a>Behavior with open operands</h3>
<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_closedopen_cube.png" alt="B-Rule illustration single vs multiple shapes" width="298"/></td>
	<td>
	<pre class="code3">

Left -->
    color("#0399F5") // blue
    primitiveCube
    union {
        color("#09DE1F") // green
        t(2,2,2) 
        comp(f) { front: NIL | all= B. }
    }
    
Right --> 
    color("#0399F5") // blue
    primitiveCube
    union {
        color("#09DE1F") // green
        t(2,2,2) 
        comp(f) { left: NIL | all= B. }
    }</pre>
	<em>Operand A is a closed cube, while operand B is an open cube. 
	<br>Left: The open boundary of B is not intersecting operand A. 
	<br>
	Right: The open boundary of B is intersecting operand A.
	</em>
	</td>
</tr>
</table>

<br><br>

<table>
<tr>
	<td class="twocol_l"><img src="images/boolOp_closedopen_plane.png" alt="B-Rule illustration non-touching" width="298"/></td>
	<td>
	<pre class="code3">
Left -->
    color("#0399F5") // blue
    primitiveCube
    union {
        color("#09DE1F") // green
        primitiveQuad
        s(12,0,12)
        center(xyz)
    }
    
Right -->
    color("#0399F5") // blue
    primitiveCube
    union {
        color("#09DE1F") // green
        primitiveQuad
        s(12,0,10)
        t(-1,5,2)
    }</pre>
	<em>Operand A is a closed cube, while operand B is a 2D quad. 
	<br>Left: The quad fully cuts the cube. Everything below the plane is regarded as "inside" and thus disappears.
	<br>
	Right:  The quad only partially cuts the cube.
	</em>
	</td>
</tr>
</table>

<!-- FOOTER -->

<p class="foot">Copyright &copy;2008-2024 Esri R&D Center Zurich. All rights reserved.</p>				  

<!-- END CENTERED CONTENT -->

</div>
</body>
</html>
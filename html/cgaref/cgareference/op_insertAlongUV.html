<html>

<head>
    <title>insertAlongUV Operation</title>
    <link rel="stylesheet" href="../manual_style.css" type="text/css" />
</head>

<body>
<div class="content">

<!-- HEADER (use only on bookchapters) -->

<table summary="" class="header">
	<tr>
		<td align="left" class="helphead_l"><a href="../toc.html"><div class="helplink">&nbsp;</div></a></td>
		<td align="right" class="helphead_r"></td>
	</tr>
</table>

<!-- CONTENT -->

<h1>insertAlongUV operation</h1>
        
<h2>Synopsis</h2>
<p class="code2">insertAlongUV(<span class="cga_opparam">uvSet</span>, <span class="cga_opparam">geometryPath</span>, <span class="cga_opparam">height</span>)</p>
<p class="code2">insertAlongUV(<span class="cga_opparam">uvSet</span>, <span class="cga_opparam">geometryPath</span>, <span class="cga_opparam">height</span>, <span class="cga_opparam">heightDirection</span>, <span class="cga_opparam">heightAlignment</span>)</p>

<h2>Parameters</h2>

<ul>
	<li><span class="cga_opparam">uvSet</span> (float)<br>
		Number of texture coordinates set (integer number in [0,9]). The numbering corresponds to the texture layers of the <a href="attr_material.html">material attribute</a>, see also <a href="cga_texturing.html"> Texturing: Essential Knowledge</a>.
	</li>	
	<li><span class="cga_opparam">geometryPath</span> (string)<br>
		File path of the geometry asset to insert. See <a class="normw" href="cga_assetSearch.html">
		Asset Search</a> for information about search locations.<br>
		The remarks about <a class="normw" href="op_i.html#supported_formats">supported asset formats</a> for the <a class="normw" href="op_i.html">i operation</a> also apply here.
	</li>
	<li><span class="cga_opparam">height</span> (float)<br>
		The height of the inserted geometry in the world coordinate system.
	</li>
	<li><span class="cga_opparam">heightDirection</span> (keyword)<br>
		<ul>
			<li><span class="codelight">scope.y</span>: Default. The height is projected along the scope's y axis. Use for example <a class="normw" href="op_alignScopeToAxes.html">alignScopeToAxes</a> or <a class="normw" href="op_alignScopeToGeometry.html">alignScopeToGeometry</a> to adjust the y axis.</li>
			<li><span class="codelight">vertex.normal</span>: The height is projected along (interpolated) vertex normals of the current shape.
				<p class="notes">Duplicate vertices must be merged in order to compute vertex normals using adjacent face normals.</p></li>
		</ul>
	</li>
	<li><span class="cga_opparam">heightAlignment</span> (keyword)<br>
		<ul>
			<li><span class="codelight">alignPosition</span>: Default. The asset is placed onto the current shape's faces.</li>
			<li><span class="codelight">keepPosition</span>: The asset's position along the height dimension is placed relative to its origin.</li>
		</ul>
	</li>
</ul>


<table>
<tr>
	<td>
	<p class="info">Reads a geometry asset (3D model, polygon mesh) from a file and inserts it along the current shape's uv coordinates by mapping the width and depth of the asset to the chosen uv-set. Specifically,</p>
	<ul>
		<li>the x-span of the asset is mapped to u in [0,1] and is repeated,</li>
		<li>the z-span is mapped to -v,</li>
		<li>the y-span is set to the chosen <span class="cga_opparam">height</span> parameter.</li>
	</ul>
	</td>
	<td class="twocol_l"><img src="images/insertAlongUV-mapping.png" alt="insertAlongUV-mapping"/></td>
</tr>
<tr>
	<td>
	<p>The asset is cut and bent to a new geometry that fits into the uv space of the initial shape.</p>
	<p>On a shape with a uv-set assigned, use <a class="normw" href="op_split.html">split</a> and texturing operations such as <a class="normw" href="op_normalizeUV.html">normalizeUV</a>, <a class="normw" href="op_rotateUV.html">rotateUV</a>, and <a class="normw" href="op_scaleUV.html">scaleUV</a> to setup the uvs according to your needs.</p>
	</td>
	<td class="twocol_l"><img src="images/insertAlongUV-cutting.png" alt="insertAlongUV-cutting"/></td>
</tr>
</table>

<p class="notes">The asset is only mapped onto triangles and quads of the current shape.</p>

<h2>Notes</h2>

<ul>
	<li>The new geometry does not inherit the vertex normals of the asset. You can (re-)compute vertex normals using <a class="normw" href="op_setNormals.html">setNormals</a> or <a class="normw" href="op_softenNormals.html">softenNormals</a>.</li>
	<li>The asset is cut in order to fit it onto the uv space. This creates coplanar edges and collinear vertices which can be removed using <a class="normw" href="op_cleanupGeometry.html">cleanupGeometry</a>.</li>
	<li>Unlike the <a class="normw" href="op_i.html">insert operation</a>, the creation of a new geometry breaks instancing. Furthermore, trimming is not applied automatically.</li>
</ul>

<h2>Related</h2>       

<ul>
	<li><a class="normw" href="op_setupProjection.html">setupProjection operation</a></li>
	<li><a class="normw" href="op_projectUV.html">projectUV operation</a></li>
	<li><a class="normw" href="op_translateUV.html">translateUV operation</a></li>
	<li><a class="normw" href="op_scaleUV.html">scaleUV operation</a></li>
	<li><a class="normw" href="op_normalizeUV.html">normalizeUV operation</a></li>
	<li><a class="normw" href="op_tileUV.html">tileUV operation</a></li>
	<li><a class="normw" href="op_rotateUV.html">rotateUV operation</a></li>
	<li><a class="normw" href="op_i.html">insert operation</a></li>
	<li><a class="normw" href="op_resetGeometry.html">resetGeometry operation</a></li>
</ul> 
        
<h2>Examples</h2>

<h3>Streets</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><img src="images/insertAlongUV-barrier-and-street.png" alt="insertAlongUV-barrier-and-street"/></br>
	                     <img src="images/insertAlongUV-barrier-on-street.png" alt="insertAlongUV-barrier-on-street"/></td>
	<td><pre class="code3">
	
	
const width  = assetInfo("barrier.obj", sx)
const height = assetInfo("barrier.obj", sy)

Street --> split(v, unitSpace, 0) {
               width : InsertBarrier |
               ~1    : Street.       |
               width : InsertBarrier |
               ~1    : Street.       |
               width : InsertBarrier }
	           
InsertBarrier -->
    rotateUV(0, 90)
    normalizeUV(0, u, collectiveAllFaces)
    insertAlongUV(0, "barrier.obj", height)
	</pre>
	<em>A road barrier asset is inserted along the uv coordinates of street shapes.</em>
	</td>
</tr>
</table>

<br>
<br>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><img src="images/insertAlongUV-barrier-2.png" alt="insertAlongUV-barrier-2" width="222"/></td>
	<td>
	<br>
	<em>If the asset is oriented with x corresponding to the u direction, <span class="codelight">rotateUV()</span> is not necessary, and the following changes produce the same result as above.</em>
	<pre class="code3">
const width = assetInfo("barrier.obj", sz)
	           
InsertBarrier -->
    normalizeUV(0, u, collectiveAllFaces)
    insertAlongUV(0, "barrier.obj", height)
	</pre>
	</td>
</tr>
</table>

<br>
<br>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><img src="images/insertAlongUV-guardrail-and-street.png" alt="insertAlongUV-guardrail-and-street"/></td>
	<td><pre class="code3">
const width  = assetInfo("guardrail.obj", sx)
const height = assetInfo("guardrail.obj", sy)
const depth  = assetInfo("guardrail.obj", sz)

Street -->
    alignScopeToAxes(y)
    split(v, unitSpace, 0) { depth : rotateUV(0, 180)
                                     InsertGuardrail
                           |    ~1 : NIL
                           | depth : InsertGuardrail }

InsertGuardrail -->
    normalizeUV(0, v, collectiveAllFaces)
    tileUV(0, ~width, 0)
    insertAlongUV(0, "guardrail.obj", height)
	</pre>
	<em>Using <span class="codelight">alignScopeToAxes(y)</span> ensures that the guard rail asset remains vertical as it is inserted along the uv coordinates of uphill street shapes.  <span class="codelight">tileUV</span> causes the asset to repeat.</em>
	</td>
</tr>
</table>

<h3>Repeating geometries</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><img src="images/insertAlongUV-spheres.png" alt="insertAlongUV-spheres"/></td>
	<td><pre class="code3">
Example1 --> split(u, uvSpace, 0) { '0.25 :
             split(v, uvSpace, 0) { '0.25 :
                 s('1, 2.5, '1)
                 i("sphere.obj")
                 Sphere.
             }* }*

Example2 --> scaleUV(0, 4.0, 4.0)
             insertAlongUV(0, "sphere.obj", 2.5)
             setNormals(auto)
	</pre>
	<em>A planar shape is split along its uv coordinates, and a sphere asset is inserted at each split node. A similar result can be achieved by transforming the uv coordinates and inserting the sphere asset along the uv coordinates. In contrast to the first example, only one leaf shape is created.</em>
	</td>
</tr>
</table>

<br>
<br>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><img src="images/insertAlongUV-trunks.png" alt="insertAlongUV-trunks"/></td>
	<td><pre class="code3">
Lot -->
    setupProjection(0, scope.zx, '0.25, '0.25)
    projectUV(0)
    [ texture("builtin:uvtest.png") Texture. ]
    insertAlongUV(0, "Orange_Tree_Analytical_0.obj", 25)
    comp(g) { 0 : set(material.opacity, 0.1)
                  Foliage. |
              1 : Trunk. } 
	</pre>
	<em>A tree model is inserted per uv-range, and its trunk is extracted using a component split.</em>
	</td>
</tr>
</table>

<h3>Curved surfaces</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><img src="images/insertAlongUV-curved-windows-on-cylinder.png" alt="insertAlongUV-curved-windows-on-cylinder"/></td>
	<td><pre class="code3">
	
	
const asset = "windowAligned.obj"
const sy    = assetInfo(asset, sy)
const sx    = assetInfo(asset, sx)
const sz    = assetInfo(asset, sz)

Lot -->
    primitiveCylinder(32, 2, 4)
    comp(f) { side = Side | all = Endcaps. }
	
Side -->
    split(u, unitSpace, 0) { sx : Split | ~1.5 : Wall. }*
           
Split -->
    split(y) { ~1: Wall. | sz: Window | ~1: Wall. }

Window -->
    normalizeUV(0, uv, collectiveAllFaces)
    insertAlongUV(0, asset, sy, vertex.normal, keepPosition)
    color("#804000")
	</pre>
	<em>The <span class="codelight">insertAlongUV</span> operation can also be used to create curved windows. By using the <span class="codelight">vertex.normal</span> option, the window asset curves around the cylinder. The <span class="codelight">keepPosition</span> option places the asset relative to its origin.</em>
	</td>
</tr>
</table>

<br>
<br>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><img src="images/insertAlongUV-circles-on-sphere.png" alt="insertAlongUV-circles-on-sphere"/></td>
	<td><pre class="code3">
Sphere -->
    primitiveSphere()
    scaleUV(0, 10, 10)
    split(y) { ~1 : insertAlongUV(0,  "pyramid.obj",   0.5,
                        vertex.normal, alignPosition)
                    color(1,0.5,0.5)
                    Pyramids.
             | ~1 : insertAlongUV(0, "circles2D.obj",  0,
                        vertex.normal, alignPosition)
                    color(0.5,1,0.5)
                    Circles2D.
             | ~1 : insertAlongUV(0, "circles3D.obj", -0.5,
                        vertex.normal, alignPosition)
                    color(0.5,0.5,1) 
                    Circles3D. }
	</pre>
	<em>In this example, both 2D and 3D assets are repeatedly inserted on a curved surface. Note that the height parameter is set to positive, zero, and negative values.</em>
	</td>
</tr>
</table>


<!-- FOOTER -->
<p class="foot">Copyright &copy;2008-2019 Esri R&amp;D Center Zurich. All rights reserved.</p>				  

<!-- END CENTERED CONTENT -->
</div>
</body>
</html>
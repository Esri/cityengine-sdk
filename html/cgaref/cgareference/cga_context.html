<html>

<head>
    <title>Context (and Occlusion) Queries</title>
    <link rel="stylesheet" href="../manual_style.css" type="text/css" />
</head>

<body>
<div class="content">

<table summary="" class="header">
	<tr>
		<td align="left" class="helphead_l"><a href="../toc.html"><div class="helplink">&nbsp;</div></a></td>
		<td align="right" class="helphead_r"></td>
	</tr>
</table>

<h1>Context (and occlusion) queries</h1>

<h2>List of available context queries</h2>

Context queries are functions that return information about contextual shapes in the environment of the current shape. Occlusion queries are special context queries that return information about the mutual intersection of geometries.

<h4>Occlusion queries</h4>

<p class="code2">bool func()</p>
<p class="code2">bool func(<span class="cga_opparam">target-selector</span>)</p>
<p class="code2">bool func(<span class="cga_opparam">target-selector</span>, <span class="cga_opparam">label</span>)</p>

<table summary="" class="twocol">
	<tr>
		<td class="twocol_l"><a class="normw" href="func_occlusion.html">inside</a></td>
		<td>Returns <span class="cga_keyword">true</span> if current shape is inside another shape geometry.</td>
	</tr>
	<tr>
		<td class="twocol_l"><a class="normw" href="func_occlusion.html">overlaps</a></td>
		<td>Returns <span class="cga_keyword">true</span> if current shape overlaps another shape geometry.</td>
	</tr>
	<tr>
		<td class="twocol_l"><a class="normw" href="func_occlusion.html">touches</a></td>
		<td>Returns <span class="cga_keyword">true</span> if current shape touches another shape geometry.</td>
	</tr>
</table>

<h4>General context queries</h4>

<p class="code2">float func(<span class="cga_opparam">target-selector</span>, <span class="cga_opparam">label</span>, <span class="cga_opparam">...</span>)</p>

<table summary="" class="twocol">
	<tr>
		<td class="twocol_l"><a class="normw" href="func_minimumDistance.html">minimumDistance</a></td>
		<td>Returns distance of current scope to scope of another labeled shape.</td>
	</tr>
	<tr>
		<td class="twocol_l"><a class="normw" href="func_contextCompare.html">contextCompare</a></td>
		<td>Returns the rank of the current shape geometry among other labeled shape geometries according to a specific comparator.</td>
	</tr>
	<tr>
		<td class="twocol_l"><a class="normw" href="func_contextCount.html">contextCount</a></td>
		<td>Returns the number of labeled shapes in the environment.</td>
	</tr>
</table>

<a name="detail"></a>
<h2>Target selectors</h2>

<p>For all functions the parameter <span class="cga_opparam">target-selector</span> determines what the current geometry is tested against and can either be <span class="codelight">intra</span>, <span class="codelight">inter</span>, or <span class="codelight">all</span>. Thus, the current geometry can be tested against geometries of shapes</p>
<ul>
	<li><span class="codelight">intra</span>: in the same shape tree (i.e. from the same inital shape) or</li>
	<li><span class="codelight">inter</span>: in other shape trees (i.e. generated by other initial shapes in the neighborhood) or</li>
	<li><span class="codelight">all</span>: in both the same and other shape trees.</li>
</ul>
<p>If no <span class="cga_opparam">target-selector</span> is given (occlusion queries), <span class="codelight">all</span> is set as default.</p>

<h2>Specifics on inter context</h2>

<h4>Neighborhood distance</h4>

<p>The initial shapes within a user-defined neighborhood distance to the bounding box of the current intial shape are taken into account. Distances are available for</p>
<ul>
	<li>occlusion queries with a default of 1 and for</li>
	<li>context queries with a default of infinity, i.e. the distance is ignored and all shapes in the scene are considered.</li>
</ul>
<p>The defaults are reasonable for most cases. The distances can be modified in the <a href="../manual/ui/cep/grammarcore.html#context" class="internlink">procedural runtime preferences</a> and are stored per scene.</p>

<p class="notes">Inter context queries possibly need to consider many initial shapes in the envronment and are computationally more expensive than intra context queries. If you aim to solely check for intra, specify the <span class="code_std">intra</span> target selector in order to avoid unnecessary overhead by inter.</p>

<h4>Scenarios</h4>

<p>Whether inter context queries consider initial shapes in their environment depends on the scenario the shapes belong to:</p>
<ul>
	<li>Shapes of a scenario are <em>not</em> considered by queries of default shapes.</li>
	<li>Default shapes are considered by queries of shapes of a scenario.</li>
	<li>Default shapes are considered by queries of default shapes.</li>
	<li>Shapes of a scenario are considered by queries of shapes of a scenario if they share at least one common scenario.</li>
</ul>
<p class="notes">The contextural influence of shapes is determined by their assigned scenarios and not by their current visibility in the viewport.</p>

<a name="twopass"></a>
<h2>Two-pass generation process</h2>

<p>At the time context queries are evaluated not all geometries that could be relevant have been generated. Additionally, context queries are typically applied in the conditional part of a rule. Their result can influence the generated model and, therefore, in turn could change the result of the queries. Because of that, a special deterministic two-pass generation process is performed for <em>intra</em> context:</p>
<ol>
	<li>Shape trees are generated with intra queries returning a default value:
	<table summary="" class="twocol">
	<tr>
		<td class="twocol_l"><a class="normw" href="func_occlusion.html">inside</a></td>
		<td><span class="cga_keyword">false</span></td>
	</tr>
	<tr>
		<td class="twocol_l"><a class="normw" href="func_occlusion.html">overlaps</a></td>
		<td><span class="cga_keyword">false</span></td>
	</tr>
	<tr>
		<td class="twocol_l"><a class="normw" href="func_occlusion.html">touches</a></td>
		<td><span class="cga_keyword">false</span></td>
	</tr>
	<tr>
		<td class="twocol_l"><a class="normw" href="func_minimumDistance.html">minimumDistance</a></td>
		<td><a class="normw" href="func_isinf.html">infinity</a></td>
	</tr>
	<tr>
		<td class="twocol_l"><a class="normw" href="func_contextCompare.html">contextCompare</a></td>
		<td>0</td>
	</tr>
	<tr>
		<td class="twocol_l"><a class="normw" href="func_contextCount.html">contextCount</a></td>
		<td>0</td>
	</tr>
	</table></li>
	<li>The derivation is re-started. This time intra context queries are evaluated by testing against the previously generated geometries of step 1.</li>
</ol>

<p>In the case of <em>inter</em> context, a deterministic behavior is achieved by similiar means. All inter queries of models in the neighborhood of the current initial shape return default values. The described method proved to be satisfactory in most practical use case scenarios.</p>

<p class="notes">Shapes that are generated conditionally by a non-default case in an <em>intra</em> occlusion query are not considered for <em>intra</em> occlusion. Shapes that are generated conditionally by a non-default case in an <em>inter</em> occlusion query are not considered for <em>inter</em> occlusion.</p>

<h2>Related</h2>
<ul>
    <li><a class="normw" href="op_label.html">label operation</a></li>
	<li><a class="normw" href="func_occlusion.html">inside function</a></li>
	<li><a class="normw" href="func_occlusion.html">overlaps function</a></li>
	<li><a class="normw" href="func_occlusion.html">touches function</a></li>
	<li><a class="normw" href="func_minimumDistance.html">minimumDistance function</a></li>
	<li><a class="normw" href="func_contextCompare.html">contextCompare function</a></li>
	<li><a class="normw" href="func_contextCount.html">contextCount function</a></li>
</ul>

<h2>Examples</h2>

<h3>Labels</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br>
	<img src="images/context-label.png" alt="context label" width="298"></td>
	<td><pre class="code3">
	
	
	
Lot --> label("label")
        print(contextCount(intra, "label"))
        label("label")
	</pre>
	<em>In a first generation process each <span class="cga_keyword">label()</span> operation creates a labeled copy of the current shape. In the second pass, the <a class="normw" href="func_contextCompare.html">contextCompare</a> query function is used to retrieve the number of all shapes with label <span class="codelight">"label"</span>.</em></td>
</tr>
</table>

<h3>Conditions</h3>

<table summary="" class="twocol">
<tr>
	<td class="twocol_l"><br>
	<img src="images/context-conditional.png" alt="context conditional" width="298"></td>
	<td><pre class="code3">
Lot   --> comp(f) { all : extrude(10) Test }

Test  --> case overlaps(intra) :                         Red
          else :                 s('2,'1,'2) center(xyz) Green
		  
Red   --> color(1,0,0)
Green --> color(0,1,0)		  
	</pre>
	<em>In this example the Lot rule is applied to an initial single shape with two faces (intra occlusion). The default <span class="cga_keyword">false</span> case of the <span class="cga_keyword">overlaps()</span> enlarges the extruded volume. Therefore, the geometry intersects the neighboring extruded volume, and the <span class="cga_keyword">overlaps()</span> query returns <span class="cga_keyword">true</span>. The enlarged occluder shape is not visible.</em>
	<pre class="code3">
	
	
	
Test --> case overlaps(intra) : s('2,'1,'2) center(xyz) Red
         else :                                         Green
	</pre>
	<em>In contrast, if we enlarge the extruded volume in the non-default <span class="cga_keyword">true</span> case, the <span class="cga_keyword">overlaps()</span> query returns <span class="cga_keyword">false</span></em>
	</td>
</tr>
</table>

<p class="foot">Copyright &copy;2008-2018 Esri R&amp;D Center Zurich. All rights reserved.</p>				  

</div>
</body>
</html>
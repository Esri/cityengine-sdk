<html>

<head>
	<title>Rule inlining</title>
	<link rel="stylesheet" href="../manual_style.css" type="text/css" />
</head>

<body>
<div class="content">

<table summary="" class="header">
	<tr>
		<td align="left" class="helphead_l"><a href="../toc.html"><div class="helplink">&nbsp;</div></a></td>
		<td align="right" class="helphead_r"></td>
	</tr>
</table>

<h1>Rule inlining</h1>

<h2>Syntax</h2>

<p class="code2"><span class="cga_op">inline</span>(<span class="cga_opparam">geometryMergeStrategy</span>) <span class="cga_opparam">Rule</span></p>
<p class="code2"><span class="cga_op">inline</span>(<span class="cga_opparam">geometryMergeStrategy</span>) <span class="cga_opparam">subdivision</span></p>
<p class="code2"><span class="cga_op">inline</span>(<span class="cga_opparam">geometryMergeStrategy</span>) <span class="cga_opparam">{ operations }</span></p>

<h2>Parameters</h2>

<ul>
    <li><span class="cga_opparam">geometryMergeStrategy</span> (selector)
    <br>Defines how the geometry of the resulting shapes are combined:  
	<table cellspacing="5">
		<tr><td width="20%"><span class="codelight">append</span></td><td>Appends the geometry as is.</td></tr>
		<tr><td width="20%"><span class="codelight">unify</span></td><td>Uses the Boolean 3D union operation.</td></tr>	
	</table>
	</li>
	<li>Syntax options: 
	<table cellspacing="5">
		<tr><td width="20%"><span class="codelight">Rule</span></td><td>Name of a rule.</td></tr>
		<tr><td width="20%"><span class="codelight">subdivision</span></td><td>A subdivison operation (see <a class="normw" href="cgaindex.html#geometrysubdivision">Geometry Subdivision</a>).</td></tr>
		<tr><td width="20%"><span class="codelight">{ operations }</span></td><td>A sequence of shape operations in curly brackets.</td></tr>
		
	</table>
	</li>
</ul>

<h2>Description</h2>
The <span class="codelight">inline</span> keyword triggers the immediate derivation of the specified rule, subdivision operation, or shape operation sequence. The resulting shapes are then automatically merged into a single shape that replaces the current shape.
In case it results in a single shape, it is taken as is. If it results in multiple shapes, their geometries are combined according to the <span class="codelight">geometryMergeStrategy</span>.
<br>If the inlined shapes have conflicting material attributes, each shape's material is written to the geometry, meaning that all materials are preserved. For other attributes, the value of the current shape is kept if the inlined shapes have conflicting values or if more than one <a class="normw" href="op_set.html">set</a> operation has occurred.
<h3>Concept</h3>
<table>
<tr>
	<td class="twocol_l"><img src="images/inline_basic_before.png" alt="Invoking a rule traditionally" width="298"/></td>
	<td>
	<pre class="code3">

Init -->
    MyRule
    color(1,0,0)
    Result.

MyRule --> 
    t('1.5, 0, 0)
    extrude(1)
    Extruded.
	</pre>
	<em>When invoking a rule (i.e. <span class="codelight">MyRule</span>), a copy of the current shape is created and added as a successor. This shape is then separately derived using the specified rule and has no effect on the current shape. Thus, the <span class="codelight">color(1,0,0)</span> operation has no effect on <span class="codelight">Extruded</span>, and the resulting shape tree has two separate leaf shapes: <span class="codelight">Extruded</span> and <span class="codelight">Result</span>.</em>
	</td>
</tr>
</table>
<br><br>
<table>
<tr>
	<td class="twocol_l"><img src="images/inline_basic_after.png" alt="Inlining a rule." width="298"/></td>
	<td>
	<pre class="code3">
Init -->
    inline(append) MyRule
    color(1,0,0)
    Result.
	</pre>
	<em>Inlining <span class="codelight">MyRule</span> allows to continue to work on its result. This means that a rule can be used like a shape operation that affects the current shape. Thus, the <span class="codelight">color(1,0,0)</span> operation continues on <span class="codelight">Extruded</span> and the resulting shape tree has only a single leaf shape: <span class="codelight">Result</span>.</em>
	</td>
</tr>
</table>

<h3>Geometry merge strategy</h3>
The correct <span class="codelight">geometryMergeStrategy</span> depends on the modeling objective. Currently, two strategies are offered:
<table cellspacing="5">
	<tr><td width="20%"><span class="codelight">append</span></td><td>Used to simply collect the geometries of multple shapes and put them into a single mesh. No geometry cleanup is performed and all components are kept as is.</td></tr>
	<tr><td width="20%"><span class="codelight">unify</span></td><td>Used to combine the geometries of intersecting shapes with Boolean 3D operations. Intersecting faces get topologically connected and inner faces are removed.</td></tr>	
</table>

</p>

<h2>Related</h2>
<ul>
	<li><a class="normw" href="op_boolOp.html">union, subtract, intersect operations</a></li>
	<li><a class="normw" href="op_tag.html">tag operation</a></li>
</ul>

<h2><a name="examples"></a>Examples</h2>

<h3>Mesh Topology</h3>

</table>
<br><br>
<table>
<tr>
	<td class="twocol_l"><img src="images/inline_append_topology.png" alt="Inline append topology." width="298"/></td>
	<td>
	<pre class="code3">
Init -->
    primitiveCube
    print("start: " + geometry.nVertices)
    inline(append) comp(f) { all: SetColor }
    print("inlined: " + geometry.nVertices)
    cleanupGeometry(vertices, 0)
    print("cleanup: " + geometry.nVertices)
    
rampValue = comp.index/comp.total
SetColor -->
    set(material.opacity, 0.9)
    color(colorRamp("spectrum", rampValue))	</pre>
	<em>Inlining is used to combine the colored faces of a cube back into a single shape. The faces are simply appended and thus do not share vertices. This can be fixed using <a class="normw" href="op_cleanupGeometry.html">cleanupGeometry</a>.</em>
	</td>
</tr>
</table>

<h3>F-Shaped Building</h3>
<table>
<tr>
	<td class="twocol_l"><img src="images/inline_fshape_before.png" alt="F-Shaped Building traditionally" width="298"/></td>
	<td>
	<pre class="code3">

Init -->
    split(z, noAdjust) 
        {  7: split(x) { ~7: House | 7: House }*
        | ~1: split(x) { ~7: NIL   | 7: House }* }

House --> 
    extrude(5)
    comp(f) { side: Fac. | top: roofGable(40) Roof. }
	</pre>
	<em>Without inlining: The initial shape is split into an F-shape. Each piece is separately extruded and a separate detached roof is built on top.</em>
	</td>
</tr>
</table>
<br><br>
<table>
<tr>
	<td class="twocol_l"><img src="images/inline_fshape_after.png" alt="F-Shaped Building with inlining" width="298"/></td>
	<td>
	<pre class="code3">
Init -->
    inline(append) FShapePieces
    cleanupGeometry(all, 0)
    House
	
FShapePieces -->
    split(z, noAdjust) 
        {  7: split(x) { ~7: Done. | 7: Done. }*
        | ~1: split(x) { ~7: NIL   | 7: Done. }* }
	</pre>
	<em>With inlining: The <span class="codelight">FShapePieces</span> rule is inlined, which combines all pieces into a single shape. With <span class="codelight">append</span> the geometry is kept as is, which means the pieces are not connected via shared edges. To connect them and merge them into a single footprint polygon, the <a class="normw" href="op_cleanupGeometry.html">cleanupGeometry</a> operation is used. This results in a single extruded mass and a single joint roof. </em>
	</td>
</tr>
</table>

<h3>Best of Two Alternatives</h3>

<table>
<tr>
	<td class="twocol_l"><img src="images/inline_best_alternative.png" alt="Best of several alternatives" width="298"/></td>
	<td>
	<pre class="code3">
Init --> 
    inline(append) {
        [ tag("LayoutA") LayoutA ]
        [ tag("LayoutB") LayoutB ]
    }
    ChooseLayout

LayoutA --> offset(-15, border)
LayoutB --> split(x) { 15: Lot. | ~10: NIL }*

taggedArea(name) = 
    sum(comp(f) { isTagged(name): geometry.area })

ChooseLayout -->
    case taggedArea("LayoutA") > taggedArea("LayoutB"):
          comp(f) { isTagged("LayoutA")= Mass }
    else: comp(f) { isTagged("LayoutB")= Mass }

Mass --> extrude(30)
	</pre>
	<em>Two different and tagged layouts are generated. Using <span class="codelight">inline(append)</span> they are combined into a single shape. 
	The <a class="normw" href="func_comp.html">comp</a> function and tags are then used to compare the area of both layouts and continue only with the larger one. 
	</em>
	</td>
</tr>
</table>

<h3>Unify Spiral Steps</h3>

<table>
<tr>
	<td class="twocol_l"><img src="images/inline_spiral_stairs.png" alt="Spiral Stairs" width="298"/></td>
	<td>
	<pre class="code3">
Init --> 
    inline(unify) StepsRec(18)
    color(0, 1, 0, 0.8)

StepsRec(nSteps) -->
    case nSteps > 0: 
        Step
        r(0, 20, 0)
        t(0, 0.18, 0)
        StepsRec(nSteps-1)
    else: 
        NIL
        
Step -->  s(0.4, 0.3, 1) primitiveCube
	</pre>
	<em>The <span class="codelight">StepsRec(ind)</span> rule recursively generates the steps of the spiral stairs. 
	When the rule is inlined using <span class="codelight">unify</span>, the steps are combined into a single shape and their geometries merged into a single watertight mesh using Boolean 3D union operations. 
	</em>
	</td>
</tr>
</table>

<h3>Inline and Tags</h3>

<table>
<tr>
	<td class="twocol_l"><img src="images/inline_unify_tags_3D.png" alt="Example of inline with tags 3D" width="298"/></td>
	<td>
	<pre class="code3">
Init -->
    inline(unify) split(x) { 3: A | 4: B | 3: C }
    comp(f) { isTagged("A"): Blue
            | isTagged("B"): Yellow
            | isTagged("C"): Red }
	
A --> primitiveCylinder tag("A")
B --> t(-1, 0.5, 0.75)  
      s(6, 2, 1.5)
      primitiveCube
      tag("B")
C --> primitiveSphere tag("C")
	</pre>
	<em>The initial shape is split into three parts, with a different primitive geometry asset inserted into each part and then <a class="normw" href="op_tag.html">tagged</a>. Inlining the <span class="codelight">split</span> using <span class="codelight">unify</span> merges them into a single watertight mesh while preserving the tags on the individual face components.</em>
	</td>
</tr>
</table>
<br><br>
<table>
<tr>
	<td class="twocol_l"><img src="images/inline_unify_tags_2D.png" alt="Example of inline with tags 2D" width="298"/></td>
	<td>
	<pre class="code3">
Init -->
    inline(unify) split(x) { 3: A | 4: B | 3: C }
    comp(f) { isTagged("A") && isTagged("B"): Green 
            | isTagged("B") && isTagged("C"): Orange
            | isTagged("A")                 : Blue
            | isTagged("B")                 : Yellow
            | isTagged("C")                 : Red }

A --> primitiveDisk tag("A")
B --> t(-1, 0, 0.75)  
      s(6, 0, 1.5)
      tag("B")
C --> tag("C")

Blue -->   color("#0399F5")
Green -->  color("#09DE1F")
Yellow --> color("#FADB19")
Red -->    color("#FF360A")
Orange --> color("#FA9100")
	</pre>
	<em>The same example in 2D. All original edges and tags are preserved, allowing to identify the intersecting parts using tags.</em>
	</td>
</tr>
</table>



<!-- FOOTER -->

<p class="foot">Copyright &copy;2008-2024 Esri R&D Center Zurich. All rights reserved.</p>				  

<!-- END CENTERED CONTENT -->

</div>
</body>
</html>
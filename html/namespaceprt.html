<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Esri Procedural Runtime: prt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="esri_prt_55px.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Esri Procedural Runtime
   &#160;<span id="projectnumber">1.8.3501</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>SDK</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceprt.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">prt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Procedural Runtime API namespace. The prt namespace contains the top level entry points into the Procedural Runtime API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceprt_1_1_string_utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt_1_1_string_utils.html">StringUtils</a></td></tr>
<tr class="memdesc:namespaceprt_1_1_string_utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for string encoding. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_annotation.html">Annotation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_annotation_argument.html">AnnotationArgument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_attributable.html">Attributable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_attributable_setter.html">AttributableSetter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_attribute_map_builder.html">AttributeMapBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_cache.html">Cache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_cache_object.html">CacheObject</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_callbacks.html">Callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_console_log_handler.html">ConsoleLogHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_decoder_info.html">DecoderInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_encoder_info.html">EncoderInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_file_log_handler.html">FileLogHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_file_output_callbacks.html">FileOutputCallbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprt_1_1_flex_lic_params.html">FlexLicParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_initial_shape.html">InitialShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_initial_shape_builder.html">InitialShapeBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprt_1_1_lic_params.html">LicParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_log_handler.html">LogHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_memory_output_callbacks.html">MemoryOutputCallbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_object.html">Object</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_occlusion_set.html">OcclusionSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_resolve_map.html">ResolveMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_resolve_map_builder.html">ResolveMapBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_rule_file_info.html">RuleFileInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprt_1_1_simple_output_callbacks.html">SimpleOutputCallbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprt_1_1_version.html">Version</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2ed198d15e4532984f5cddcbefb38984"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ed198d15e4532984f5cddcbefb38984"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>AnnotationArgumentType</b> { <br />
&#160;&#160;<b>AAT_VOID</b>, 
<br />
&#160;&#160;<b>AAT_BOOL</b>, 
<br />
&#160;&#160;<b>AAT_FLOAT</b>, 
<br />
&#160;&#160;<b>AAT_STR</b>, 
<br />
&#160;&#160;<b>AAT_INT</b>, 
<br />
&#160;&#160;<b>AAT_UNKNOWN</b>
<br />
 }</td></tr>
<tr class="separator:a2ed198d15e4532984f5cddcbefb38984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b29d4b042552859e22f878ca115c3f4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a4b29d4b042552859e22f878ca115c3f4">CGAErrorLevel</a> { <br />
&#160;&#160;<b>CGAERROR</b>, 
<br />
&#160;&#160;<b>CGAWARNING</b>, 
<br />
&#160;&#160;<b>CGAINFO</b>
<br />
 }</td></tr>
<tr class="separator:a4b29d4b042552859e22f878ca115c3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbc8b7c3113196a20860f569f833b2d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2d">ContentType</a> { <br />
&#160;&#160;<a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2da521d06c4691563e0b22211ab302bc237">CT_UNDEFINED</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2daf5830e04b7c669cca996e5c15f81d113">CT_GEOMETRY</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2dab21c7e26c2484c474175c480bf3f708f">CT_MATERIAL</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2da3c9387bc42237c8350f24ea6aa02e1fc">CT_TEXTURE</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2da0448151e30436adb9f8e0862988a6949">CT_SHADER</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2da5430c807b61d5e420416a8157dde02cb">CT_CGB</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2daabc20900399a2c7a229b16351ce3d4d0">CT_INITIALSHAPE</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2da0c19dca5553fbcc88e281d33c362f44c">CT_CGAERROR</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2dabd6acd06505966cf37c58720f01ce7bc">CT_CGAPRINT</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2dad1e7fb4adffe37f36f4d95405f900198">CT_CGAREPORT</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2da93dc48bccb81d983e47a7b4ee355c85f">CT_ATTRIBUTE</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2da19c5a6fd7403ad949537fbcd32dab9a0">CT_SHAPETREE</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2dac4a5b07eb9e5ceae5c6cf7657a9fbcb9">CT_COUNT</a>
<br />
 }</td></tr>
<tr class="separator:a0bbc8b7c3113196a20860f569f833b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35a3cef5502bd6490d1742bd427916a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#ac35a3cef5502bd6490d1742bd427916a">LogLevel</a> { <br />
&#160;&#160;<b>LOG_TRACE</b> = 0, 
<br />
&#160;&#160;<b>LOG_DEBUG</b> = 1, 
<br />
&#160;&#160;<b>LOG_INFO</b> = 2, 
<br />
&#160;&#160;<b>LOG_WARNING</b> = 3, 
<br />
&#160;&#160;<b>LOG_ERROR</b> = 4, 
<br />
&#160;&#160;<b>LOG_FATAL</b> = 5, 
<br />
&#160;&#160;<b>LOG_NO</b> = 1000
<br />
 }</td></tr>
<tr class="separator:ac35a3cef5502bd6490d1742bd427916a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0b3066b48a14bccb756bee9a4700e4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> { <br />
&#160;&#160;<b>STATUS_OK</b>, 
<br />
&#160;&#160;<b>STATUS_UNSPECIFIED_ERROR</b>, 
<br />
&#160;&#160;<b>STATUS_OUT_OF_MEM</b>, 
<br />
&#160;&#160;<b>STATUS_NO_LICENSE</b>, 
<br />
&#160;&#160;<b>STATUS_NOT_ALL_IS_GENERATED</b>, 
<br />
&#160;&#160;<b>STATUS_INCOMPATIBLE_IS</b>, 
<br />
&#160;&#160;<b>STATUS_FILE_NOT_FOUND</b>, 
<br />
&#160;&#160;<b>STATUS_FILE_ALREADY_EXISTS</b>, 
<br />
&#160;&#160;<b>STATUS_COULD_NOT_OPEN_FILE</b>, 
<br />
&#160;&#160;<b>STATUS_COULD_NOT_CLOSE_FILE</b>, 
<br />
&#160;&#160;<b>STATUS_FILE_WRITE_FAILED</b>, 
<br />
&#160;&#160;<b>STATUS_FILE_SEEK_FAILED</b>, 
<br />
&#160;&#160;<b>STATUS_FILE_TELL_FAILED</b>, 
<br />
&#160;&#160;<b>STATUS_NO_SEEK</b>, 
<br />
&#160;&#160;<b>STATUS_EMPTY_FILE</b>, 
<br />
&#160;&#160;<b>STATUS_INVALID_URI</b>, 
<br />
&#160;&#160;<b>STATUS_ADAPTOR_NOT_FOUND</b>, 
<br />
&#160;&#160;<b>STATUS_DECODER_NOT_FOUND</b>, 
<br />
&#160;&#160;<b>STATUS_ENCODER_NOT_FOUND</b>, 
<br />
&#160;&#160;<b>STATUS_UNABLE_TO_RESOLVE</b>, 
<br />
&#160;&#160;<b>STATUS_CHECK_ERROR_PARAM</b>, 
<br />
&#160;&#160;<b>STATUS_KEY_NOT_FOUND</b>, 
<br />
&#160;&#160;<b>STATUS_KEY_ALREADY_TAKEN</b>, 
<br />
&#160;&#160;<b>STATUS_KEY_NOT_SUPPORTED</b>, 
<br />
&#160;&#160;<b>STATUS_STRING_TRUNCATED</b>, 
<br />
&#160;&#160;<b>STATUS_ILLEGAL_CALLBACK_OBJECT</b>, 
<br />
&#160;&#160;<b>STATUS_ILLEGAL_LOG_HANDLER</b>, 
<br />
&#160;&#160;<b>STATUS_ILLEGAL_LOG_LEVEL</b>, 
<br />
&#160;&#160;<b>STATUS_ILLEGAL_VALUE</b>, 
<br />
&#160;&#160;<b>STATUS_NO_RULEFILE</b>, 
<br />
&#160;&#160;<b>STATUS_NO_INITIAL_SHAPE</b>, 
<br />
&#160;&#160;<b>STATUS_CGB_ERROR</b>, 
<br />
&#160;&#160;<b>STATUS_NOT_INITIALIZED</b>, 
<br />
&#160;&#160;<b>STATUS_ALREADY_INITIALIZED</b>, 
<br />
&#160;&#160;<b>STATUS_INCONSISTENT_TEXTURE_PARAMS</b>, 
<br />
&#160;&#160;<b>STATUS_CANCELED</b>, 
<br />
&#160;&#160;<b>STATUS_UNKNOWN_ATTRIBUTE</b>, 
<br />
&#160;&#160;<b>STATUS_UNKNOWN_RULE</b>, 
<br />
&#160;&#160;<b>STATUS_ARGUMENTS_MISMATCH</b>, 
<br />
&#160;&#160;<b>STATUS_BUFFER_TO_SMALL</b>, 
<br />
&#160;&#160;<b>STATUS_UNKNOWN_FORMAT</b>, 
<br />
&#160;&#160;<b>STATUS_ENCODE_FAILED</b>, 
<br />
&#160;&#160;<b>STATUS_ATTRIBUTES_ALREADY_SET</b>, 
<br />
&#160;&#160;<b>STATUS_ATTRIBUTES_NOT_SET</b>, 
<br />
&#160;&#160;<b>STATUS_GEOMETRY_ALREADY_SET</b>, 
<br />
&#160;&#160;<b>STATUS_GEOMETRY_NOT_SET</b>, 
<br />
&#160;&#160;<b>STATUS_ILLEGAL_GEOMETRY</b>
<br />
 }</td></tr>
<tr class="separator:acf0b3066b48a14bccb756bee9a4700e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a89e46749c5dc39f359a2eb0d0e970c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a89e46749c5dc39f359a2eb0d0e970c20">addLogHandler</a> (<a class="el" href="classprt_1_1_log_handler.html">LogHandler</a> *logHandler)</td></tr>
<tr class="separator:a89e46749c5dc39f359a2eb0d0e970c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2da61548a50cf549090a613d23ec3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprt_1_1_decoder_info.html">DecoderInfo</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#aaf2da61548a50cf549090a613d23ec3b">createDecoderInfo</a> (const wchar_t *decoderId, <a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> *stat=nullptr)</td></tr>
<tr class="separator:aaf2da61548a50cf549090a613d23ec3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139ddfbf80758a1e4fbbcff7bd55d404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprt_1_1_encoder_info.html">EncoderInfo</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a139ddfbf80758a1e4fbbcff7bd55d404">createEncoderInfo</a> (const wchar_t *encoderId, <a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> *stat=nullptr)</td></tr>
<tr class="separator:a139ddfbf80758a1e4fbbcff7bd55d404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a26fc77ff5cc864b72c542114245ad1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprt_1_1_resolve_map.html">ResolveMap</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a4a26fc77ff5cc864b72c542114245ad1">createResolveMap</a> (const wchar_t *rpkURI, const wchar_t *unpackFileSystemPath=nullptr, <a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> *stat=nullptr)</td></tr>
<tr class="separator:a4a26fc77ff5cc864b72c542114245ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6125100b4deb1273c0e81cda996d89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprt_1_1_rule_file_info.html">RuleFileInfo</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a7c6125100b4deb1273c0e81cda996d89">createRuleFileInfo</a> (const wchar_t *ruleFileURI, <a class="el" href="classprt_1_1_cache.html">Cache</a> *cache=nullptr, <a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> *stat=nullptr)</td></tr>
<tr class="separator:a7c6125100b4deb1273c0e81cda996d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785b02f26edd5ec806607ab98d5761ae"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a785b02f26edd5ec806607ab98d5761ae">createTextureMetadata</a> (const wchar_t *uri, <a class="el" href="classprt_1_1_cache.html">Cache</a> *cache=nullptr, <a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> *stat=nullptr)</td></tr>
<tr class="separator:a785b02f26edd5ec806607ab98d5761ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe8090353f524a61fcf36af4a99e645"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#abfe8090353f524a61fcf36af4a99e645">encodeTexture</a> (const <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> *metadata, const uint8_t *pixeldata, const wchar_t *encoderId, const <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> *encoderOptions, <a class="el" href="classprt_1_1_simple_output_callbacks.html">SimpleOutputCallbacks</a> *soc)</td></tr>
<tr class="separator:abfe8090353f524a61fcf36af4a99e645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310381e586ced8f4b08efd472a6f0782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a310381e586ced8f4b08efd472a6f0782">generate</a> (const <a class="el" href="classprt_1_1_initial_shape.html">InitialShape</a> *const *initialShapes, size_t initialShapeCount, const OcclusionSet::Handle *occlusionHandles, const wchar_t *const *encoders, size_t encodersCount, const <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> *const *encoderOptions, <a class="el" href="classprt_1_1_callbacks.html">Callbacks</a> *callbacks, <a class="el" href="classprt_1_1_cache.html">Cache</a> *cache, const <a class="el" href="classprt_1_1_occlusion_set.html">OcclusionSet</a> *occlSet, const <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> *generateOptions=nullptr)</td></tr>
<tr class="separator:a310381e586ced8f4b08efd472a6f0782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5da776d9c068f14224cf52a902582c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#af5da776d9c068f14224cf52a902582c8">generate</a> (const <a class="el" href="classprt_1_1_initial_shape.html">InitialShape</a> *const *initialShapes, size_t initialShapeCount, const OcclusionSet::Handle *occlusionHandles, const wchar_t *const *encoders, size_t encodersCount, const <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> *const *encoderOptions, <a class="el" href="classprt_1_1_callbacks.html">Callbacks</a> *callbacks, <a class="el" href="classprt_1_1_cache.html">Cache</a> *cache, const <a class="el" href="classprt_1_1_occlusion_set.html">OcclusionSet</a> *const *occlSets, const size_t *occlSetCounts, const <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> *generateOptions=nullptr)</td></tr>
<tr class="separator:af5da776d9c068f14224cf52a902582c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73afacb3ccae1d1c9f1af5521a79fefa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a73afacb3ccae1d1c9f1af5521a79fefa">generateOccluders</a> (const <a class="el" href="classprt_1_1_initial_shape.html">InitialShape</a> *const *initialShapes, size_t initialShapeCount, OcclusionSet::Handle *occlusionHandles, const wchar_t *const *encoders, size_t encodersCount, const <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> *const *encoderOptions, <a class="el" href="classprt_1_1_callbacks.html">Callbacks</a> *callbacks, <a class="el" href="classprt_1_1_cache.html">Cache</a> *cache, <a class="el" href="classprt_1_1_occlusion_set.html">OcclusionSet</a> *occlSet, const <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> *generateOptions=nullptr)</td></tr>
<tr class="separator:a73afacb3ccae1d1c9f1af5521a79fefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25a90488eeae74f63442d12ac0583a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprt.html#ac35a3cef5502bd6490d1742bd427916a">LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#af25a90488eeae74f63442d12ac0583a2">getLogLevel</a> (<a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> *status=nullptr)</td></tr>
<tr class="separator:af25a90488eeae74f63442d12ac0583a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356d4059266a53b3ab45fe1ff6a66a4d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a356d4059266a53b3ab45fe1ff6a66a4d">getStatusDescription</a> (<a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> stat)</td></tr>
<tr class="separator:a356d4059266a53b3ab45fe1ff6a66a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2c3b2fef77f2d7da8ab5919687507c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a2b2c3b2fef77f2d7da8ab5919687507c">getTexturePixeldata</a> (const wchar_t *uri, uint8_t *buffer, size_t bufferSize, <a class="el" href="classprt_1_1_cache.html">Cache</a> *cache=nullptr)</td></tr>
<tr class="separator:a2b2c3b2fef77f2d7da8ab5919687507c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6694b33fa488d9eaf0ff21ac43dec3e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprt_1_1_version.html">Version</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a6694b33fa488d9eaf0ff21ac43dec3e5">getVersion</a> ()</td></tr>
<tr class="separator:a6694b33fa488d9eaf0ff21ac43dec3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389d6191a10c5ae7dfc86dcce24c311d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classprt_1_1_object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init</a> (const wchar_t *const *prtPlugins, size_t prtPluginsCount, <a class="el" href="namespaceprt.html#ac35a3cef5502bd6490d1742bd427916a">LogLevel</a> logLevel, const <a class="el" href="structprt_1_1_lic_params.html">LicParams</a> *lic, <a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> *stat=nullptr)</td></tr>
<tr class="separator:a389d6191a10c5ae7dfc86dcce24c311d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c181e1d9092e6ace287a8c951b36a97"><td class="memItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a4c181e1d9092e6ace287a8c951b36a97">listDecoderIds</a> (wchar_t *result, size_t *resultSize, <a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> *stat=nullptr)</td></tr>
<tr class="separator:a4c181e1d9092e6ace287a8c951b36a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45926fb4d54c985c1af7bcd904bf212"><td class="memItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#ad45926fb4d54c985c1af7bcd904bf212">listEncoderIds</a> (wchar_t *result, size_t *resultSize, <a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> *stat=nullptr)</td></tr>
<tr class="separator:ad45926fb4d54c985c1af7bcd904bf212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4337b6cedb6d554afe1875c874047f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a0b4337b6cedb6d554afe1875c874047f">log</a> (const wchar_t *msg, <a class="el" href="namespaceprt.html#ac35a3cef5502bd6490d1742bd427916a">LogLevel</a> level)</td></tr>
<tr class="separator:a0b4337b6cedb6d554afe1875c874047f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e58922795880d9c4e5200f05ca0ae07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a0e58922795880d9c4e5200f05ca0ae07">removeLogHandler</a> (<a class="el" href="classprt_1_1_log_handler.html">LogHandler</a> *logHandler)</td></tr>
<tr class="separator:a0e58922795880d9c4e5200f05ca0ae07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134acce0e87126ded51dcbe9b1f9299b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprt.html#a134acce0e87126ded51dcbe9b1f9299b">setLogLevel</a> (<a class="el" href="namespaceprt.html#ac35a3cef5502bd6490d1742bd427916a">LogLevel</a> level)</td></tr>
<tr class="separator:a134acce0e87126ded51dcbe9b1f9299b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Procedural Runtime API namespace. The prt namespace contains the top level entry points into the Procedural Runtime API. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a4b29d4b042552859e22f878ca115c3f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceprt.html#a4b29d4b042552859e22f878ca115c3f4">prt::CGAErrorLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Error level for CGAErrors. </p>

</div>
</div>
<a class="anchor" id="a0bbc8b7c3113196a20860f569f833b2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceprt.html#a0bbc8b7c3113196a20860f569f833b2d">prt::ContentType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes the types handled by Decoders and Encoders. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a0bbc8b7c3113196a20860f569f833b2da521d06c4691563e0b22211ab302bc237"></a>CT_UNDEFINED&#160;</td><td class="fielddoc">
<p>extension does not make use of specific content type, e.g. adaptor extensions </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0bbc8b7c3113196a20860f569f833b2daf5830e04b7c669cca996e5c15f81d113"></a>CT_GEOMETRY&#160;</td><td class="fielddoc">
<p>extension can handle geometries (and potentially also materials and textures) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0bbc8b7c3113196a20860f569f833b2dab21c7e26c2484c474175c480bf3f708f"></a>CT_MATERIAL&#160;</td><td class="fielddoc">
<p>extension can handle materials (and potentially also textures) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0bbc8b7c3113196a20860f569f833b2da3c9387bc42237c8350f24ea6aa02e1fc"></a>CT_TEXTURE&#160;</td><td class="fielddoc">
<p>extension can handle textures </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0bbc8b7c3113196a20860f569f833b2da0448151e30436adb9f8e0862988a6949"></a>CT_SHADER&#160;</td><td class="fielddoc">
<p>extension can handle shader resources </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0bbc8b7c3113196a20860f569f833b2da5430c807b61d5e420416a8157dde02cb"></a>CT_CGB&#160;</td><td class="fielddoc">
<p>extension can handle CGB resources </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0bbc8b7c3113196a20860f569f833b2daabc20900399a2c7a229b16351ce3d4d0"></a>CT_INITIALSHAPE&#160;</td><td class="fielddoc">
<p>(reserved) extension can handle initial shape </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0bbc8b7c3113196a20860f569f833b2da0c19dca5553fbcc88e281d33c362f44c"></a>CT_CGAERROR&#160;</td><td class="fielddoc">
<p>extension can handle CGA error events </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0bbc8b7c3113196a20860f569f833b2dabd6acd06505966cf37c58720f01ce7bc"></a>CT_CGAPRINT&#160;</td><td class="fielddoc">
<p>extension can handle CGA print events (see cga <a href="cgaref/cgareference/op_print.html">print()</a>) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0bbc8b7c3113196a20860f569f833b2dad1e7fb4adffe37f36f4d95405f900198"></a>CT_CGAREPORT&#160;</td><td class="fielddoc">
<p>extension can handle CGA report events (see cga <a href="cgaref/cgareference/op_report.html">report()</a>) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0bbc8b7c3113196a20860f569f833b2da93dc48bccb81d983e47a7b4ee355c85f"></a>CT_ATTRIBUTE&#160;</td><td class="fielddoc">
<p>extension can handle CGA attributes </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0bbc8b7c3113196a20860f569f833b2da19c5a6fd7403ad949537fbcd32dab9a0"></a>CT_SHAPETREE&#160;</td><td class="fielddoc">
<p>extension can handle shape trees </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0bbc8b7c3113196a20860f569f833b2dac4a5b07eb9e5ceae5c6cf7657a9fbcb9"></a>CT_COUNT&#160;</td><td class="fielddoc">
<p>sentinel value </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ac35a3cef5502bd6490d1742bd427916a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceprt.html#ac35a3cef5502bd6490d1742bd427916a">prt::LogLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loglevels for the the logger. </p>

</div>
</div>
<a class="anchor" id="acf0b3066b48a14bccb756bee9a4700e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">prt::Status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Status enum is used to indicate whether a function was successful or not. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceprt.html#a356d4059266a53b3ab45fe1ff6a66a4d">getStatusDescription()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a89e46749c5dc39f359a2eb0d0e970c20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> prt::addLogHandler </td>
          <td>(</td>
          <td class="paramtype">LogHandler *&#160;</td>
          <td class="paramname"><em>logHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a log handler, can be called at any time (also before <a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init()</a>). Is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logHandler</td><td><a class="el" href="classprt_1_1_log_handler.html">LogHandler</a> to register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf2da61548a50cf549090a613d23ec3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprt_1_1_decoder_info.html">DecoderInfo</a> const* prt::createDecoderInfo </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>decoderId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Status *&#160;</td>
          <td class="paramname"><em>stat</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an <a class="el" href="classprt_1_1_decoder_info.html">DecoderInfo</a> instance for the given decoder id.</p>
<p>Must be called after <a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init()</a>, will return STATUS_NOT_INITIALIZED else. Is thread-safe. The returned instance must be destroyed by the caller.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classprt_1_1_decoder_info.html">DecoderInfo</a>, <a class="el" href="namespaceprt.html#a4c181e1d9092e6ace287a8c951b36a97">listDecoderIds</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">encoderID</td><td>ID of encoder to get <a class="el" href="classprt_1_1_encoder_info.html">EncoderInfo</a> for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stat</td><td>Optional pointer to return the status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="classprt_1_1_decoder_info.html">DecoderInfo</a> instance on success or 0 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a139ddfbf80758a1e4fbbcff7bd55d404"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprt_1_1_encoder_info.html">EncoderInfo</a> const* prt::createEncoderInfo </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>encoderId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Status *&#160;</td>
          <td class="paramname"><em>stat</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an <a class="el" href="classprt_1_1_encoder_info.html">EncoderInfo</a> instance for the given encoder id.</p>
<p>Must be called after <a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init()</a>, will return STATUS_NOT_INITIALIZED else. Is thread-safe. The returned instance must be destroyed by the caller.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classprt_1_1_encoder_info.html">EncoderInfo</a>, <a class="el" href="namespaceprt.html#ad45926fb4d54c985c1af7bcd904bf212">listEncoderIds</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">encoderID</td><td>ID of encoder to get <a class="el" href="classprt_1_1_encoder_info.html">EncoderInfo</a> for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stat</td><td>Optional pointer to return the status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="classprt_1_1_encoder_info.html">EncoderInfo</a> instance on success or 0 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a26fc77ff5cc864b72c542114245ad1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprt_1_1_resolve_map.html">ResolveMap</a> const* prt::createResolveMap </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>rpkURI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>unpackFileSystemPath</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Status *&#160;</td>
          <td class="paramname"><em>stat</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classprt_1_1_resolve_map.html">ResolveMap</a> for a rpk. The entries will point into the rpk.</p>
<p>Must be called after <a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init()</a>, will return STATUS_NOT_INITIALIZED else. Is thread-safe. The returned instance must be destroyed by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">rpkURI</td><td>URI to the rpk, see <a class="el" href="_app_notes.html">Application Notes</a> for URI creation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">unpackFileSystemPath</td><td>Optional. If non-null, the rpk gets unpacked to the given directory in the filesystem and the <a class="el" href="classprt_1_1_resolve_map.html">ResolveMap</a> entries will point to those files. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stat</td><td>Optional pointer to return the status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="classprt_1_1_resolve_map.html">ResolveMap</a> instance on success or 0 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c6125100b4deb1273c0e81cda996d89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprt_1_1_rule_file_info.html">RuleFileInfo</a> const* prt::createRuleFileInfo </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>ruleFileURI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cache *&#160;</td>
          <td class="paramname"><em>cache</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Status *&#160;</td>
          <td class="paramname"><em>stat</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classprt_1_1_rule_file_info.html">RuleFileInfo</a> instance for a cgb file.</p>
<p>Must be called after <a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init()</a>, will return STATUS_NOT_INITIALIZED else. Is thread-safe. The returned instance must be destroyed by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ruleFileURI</td><td>URI to the cgb file, see <a class="el" href="_app_notes.html">Application Notes</a> for URI creation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cache</td><td>Optional <a class="el" href="classprt_1_1_cache.html">Cache</a> instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stat</td><td>Optional pointer to return the status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <a class="el" href="classprt_1_1_rule_file_info.html">RuleFileInfo</a> instance on success or 0 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a785b02f26edd5ec806607ab98d5761ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a>* prt::createTextureMetadata </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cache *&#160;</td>
          <td class="paramname"><em>cache</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Status *&#160;</td>
          <td class="paramname"><em>stat</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> with the metadata for a given texture URI. See <a class="el" href="classprtx_1_1_texture.html">prtx::Texture</a> for a list of supported metadata attributes.</p>
<p>Must be called after <a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init()</a>, will return STATUS_NOT_INITIALIZED else. Is thread-safe. The returned instance must be destroyed by the caller.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceprt.html#a2b2c3b2fef77f2d7da8ab5919687507c">getTexturePixeldata()</a>, <a class="el" href="classprt_1_1_attributable.html#aaa464b033212c723bf25b39383b19012">Attributable::PrimitiveType</a>, <a class="el" href="classprtx_1_1_texture.html">prtx::Texture</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">uri</td><td>URI of the texture, see <a class="el" href="_app_notes.html">Application Notes</a> for URI creation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cache</td><td>Optional <a class="el" href="classprt_1_1_cache.html">Cache</a> instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stat</td><td>Optional pointer to return the status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> instance on success or 0 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="abfe8090353f524a61fcf36af4a99e645"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> prt::encodeTexture </td>
          <td>(</td>
          <td class="paramtype">const AttributeMap *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pixeldata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>encoderId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeMap *&#160;</td>
          <td class="paramname"><em>encoderOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimpleOutputCallbacks *&#160;</td>
          <td class="paramname"><em>soc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes the passed texture and writes the result to the passed <a class="el" href="classprt_1_1_simple_output_callbacks.html">SimpleOutputCallbacks</a> instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metadata</td><td>The textures metadata, must contain width/height/format attributes. Other attributes are optional and it depends on the encoder whether they are supported. See <a class="el" href="classprtx_1_1_texture.html">prtx::Texture</a> for a list of supported metadata attributes. </td></tr>
    <tr><td class="paramname">pixeldata</td><td>The pixeldata to encode </td></tr>
    <tr><td class="paramname">encoderId</td><td>Id of the encoder to use. </td></tr>
    <tr><td class="paramname">encoderOptions</td><td>Options for the encoder. This includes the filename. </td></tr>
    <tr><td class="paramname">soc</td><td>The <a class="el" href="classprt_1_1_simple_output_callbacks.html">SimpleOutputCallbacks</a> instance which will receive the encoded texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status. </dd></dl>

</div>
</div>
<a class="anchor" id="a310381e586ced8f4b08efd472a6f0782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> prt::generate </td>
          <td>(</td>
          <td class="paramtype">const InitialShape *const *&#160;</td>
          <td class="paramname"><em>initialShapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initialShapeCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OcclusionSet::Handle *&#160;</td>
          <td class="paramname"><em>occlusionHandles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *const *&#160;</td>
          <td class="paramname"><em>encoders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>encodersCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeMap *const *&#160;</td>
          <td class="paramname"><em>encoderOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callbacks *&#160;</td>
          <td class="paramname"><em>callbacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cache *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OcclusionSet *&#160;</td>
          <td class="paramname"><em>occlSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeMap *&#160;</td>
          <td class="paramname"><em>generateOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate and encode procedural models for a number of initial shapes.</p>
<p>Must be called after <a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init()</a>, will return STATUS_NOT_INITIALIZED else. Is thread-safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classprt_1_1_callbacks.html">Callbacks</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialShapes</td><td>The initial shapes for which the procedural models have to be generated. </td></tr>
    <tr><td class="paramname">initialShapeCount</td><td>The number of initial shapes in the array. </td></tr>
    <tr><td class="paramname">occlusionHandles</td><td>One occlusion handle for each initial shape. Set to nullptr for no inter-model occlusion tests. Use <a class="el" href="namespaceprt.html#a73afacb3ccae1d1c9f1af5521a79fefa">generateOccluders()</a> to obtain the occlusion handles. </td></tr>
    <tr><td class="paramname">encoders</td><td>A number (&gt;= 1) of encoders to use to encode the generated model. The encoders are identified by their ID, see <a class="el" href="classprt_1_1_encoder_info.html#a704f84cbf467183b9a2855a9c1064f36">EncoderInfo::getID()</a>. </td></tr>
    <tr><td class="paramname">encodersCount</td><td>The number of encoder ids in the array. </td></tr>
    <tr><td class="paramname">encoderOptions</td><td>One <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> with the enocder options for each encoder. </td></tr>
    <tr><td class="paramname">callbacks</td><td>Pointer to an instance of an implementation of the <a class="el" href="classprt_1_1_callbacks.html">Callbacks</a> interface. </td></tr>
    <tr><td class="paramname">cache</td><td>Pointer to an instance of an implementation of the <a class="el" href="classprt_1_1_cache.html">Cache</a> interface. See <a class="el" href="classprt_1_1_cache_object.html">CacheObject</a>. </td></tr>
    <tr><td class="paramname">occlSet</td><td>The <a class="el" href="classprt_1_1_occlusion_set.html">OcclusionSet</a> which contains the occlusionHandles. Set to nullptr for no inter-model occlusion tests. </td></tr>
    <tr><td class="paramname">generateOptions</td><td>An optional <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> to set advanced generate options.<br />
 int "numberWorkerThreads": number of worker threads to internally use for generation. 0 = no multithreading = default<br />
 bool "cacheShapeTree": cache the generated shapetrees. default = false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a status code. </dd></dl>

</div>
</div>
<a class="anchor" id="af5da776d9c068f14224cf52a902582c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> prt::generate </td>
          <td>(</td>
          <td class="paramtype">const InitialShape *const *&#160;</td>
          <td class="paramname"><em>initialShapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initialShapeCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OcclusionSet::Handle *&#160;</td>
          <td class="paramname"><em>occlusionHandles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *const *&#160;</td>
          <td class="paramname"><em>encoders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>encodersCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeMap *const *&#160;</td>
          <td class="paramname"><em>encoderOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callbacks *&#160;</td>
          <td class="paramname"><em>callbacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cache *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OcclusionSet *const *&#160;</td>
          <td class="paramname"><em>occlSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>occlSetCounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeMap *&#160;</td>
          <td class="paramname"><em>generateOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate and encode procedural models for a number of initial shapes.</p>
<p>Must be called after <a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init()</a>, will return STATUS_NOT_INITIALIZED else. Is thread-safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classprt_1_1_callbacks.html">Callbacks</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialShapes</td><td>The initial shapes for which the procedural models have to be generated. </td></tr>
    <tr><td class="paramname">initialShapeCount</td><td>The number of initial shapes in the array. </td></tr>
    <tr><td class="paramname">occlusionHandles</td><td>One occlusion handle for each initial shape. Set to nullptr for no inter-model occlusion tests. Each occlusion handle corresponds to one of the given occlusion sets. Use <a class="el" href="namespaceprt.html#a73afacb3ccae1d1c9f1af5521a79fefa">generateOccluders()</a> to obtain the occlusion handles. </td></tr>
    <tr><td class="paramname">encoders</td><td>A number (&gt;= 1) of encoders to use to encode the generated model. The encoders are identified by their ID, see <a class="el" href="classprt_1_1_encoder_info.html#a704f84cbf467183b9a2855a9c1064f36">EncoderInfo::getID()</a>. </td></tr>
    <tr><td class="paramname">encodersCount</td><td>The number of encoder ids in the array. </td></tr>
    <tr><td class="paramname">encoderOptions</td><td>One <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> with the enocder options for each encoder. </td></tr>
    <tr><td class="paramname">callbacks</td><td>Pointer to an instance of an implementation of the <a class="el" href="classprt_1_1_callbacks.html">Callbacks</a> interface. </td></tr>
    <tr><td class="paramname">cache</td><td>Pointer to an instance of an implementation of the <a class="el" href="classprt_1_1_cache.html">Cache</a> interface. See <a class="el" href="classprt_1_1_cache_object.html">CacheObject</a>. </td></tr>
    <tr><td class="paramname">occlSets</td><td>The OcclusionSets which contain the occlusionHandles. Set to nullptr for no inter-model occlusion tests. OcclusionSets are stored subsequently for each initial shape. Each initial shape can have 0, 1 or &gt;1 OcclusionSets. The number of OcclusionSets of an initial shape is stored in occlSetCounts. </td></tr>
    <tr><td class="paramname">occlSetCounts</td><td>The number of OcclusionSets in occlSets for each initial shape. Set to nullptr for no inter-model occlusion tests. </td></tr>
    <tr><td class="paramname">generateOptions</td><td>An optional <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> to set advanced generate options.<br />
 int "numberWorkerThreads": number of worker threads to internally use for generation. 0 = no multithreading = default<br />
 bool "cacheShapeTree": cache the generated shapetrees. default = false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a status code. </dd></dl>

</div>
</div>
<a class="anchor" id="a73afacb3ccae1d1c9f1af5521a79fefa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> prt::generateOccluders </td>
          <td>(</td>
          <td class="paramtype">const InitialShape *const *&#160;</td>
          <td class="paramname"><em>initialShapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initialShapeCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OcclusionSet::Handle *&#160;</td>
          <td class="paramname"><em>occlusionHandles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *const *&#160;</td>
          <td class="paramname"><em>encoders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>encodersCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeMap *const *&#160;</td>
          <td class="paramname"><em>encoderOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callbacks *&#160;</td>
          <td class="paramname"><em>callbacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cache *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OcclusionSet *&#160;</td>
          <td class="paramname"><em>occlSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeMap *&#160;</td>
          <td class="paramname"><em>generateOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate an <a class="el" href="classprt_1_1_occlusion_set.html">OcclusionSet</a> with occluder geometries for each initial shape and return an occlusion handle for each one. These handles (and the <a class="el" href="classprt_1_1_occlusion_set.html">OcclusionSet</a>) can then be used to <a class="el" href="namespaceprt.html#a310381e586ced8f4b08efd472a6f0782">generate()</a> models based on rules with inter-model context and occlusion queries.</p>
<p>Must be called after <a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init()</a>, will return STATUS_NOT_INITIALIZED else. Is thread-safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classprt_1_1_callbacks.html">Callbacks</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">initialShapes</td><td>The initial shapes for which the occluders have to be generated. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">initialShapeCount</td><td>The number of initial shapes in the array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">occlusionHandles</td><td>Must be preallocated to hold initialShapeCount occlusion Handles, one for each initial shape. occlusionHandles[i] will receive the occlusion handle for initialShapes[i]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">encoders</td><td>Optional encoders to run on the generated shapetree. Set to nullptr if no extra encoders should be used. Note that many encoders only consider leaf shapes and do not capture the correct occluder geometry; these are typically the encoders from the com.esri.prt.codecs plugin. Encoders which traverse the whole shapetree (such as com.esri.prt.core.CGAPrintEncoder, com.esri.prt.core.CGAErrorEncoder or com.esri.prt.core.CGAReportEncoder) can safely be used here. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">encodersCount</td><td>The number of encoder ids in the array. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">encoderOptions</td><td>Options for the additional encoders. Use nullptr if no encoders are used. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">callbacks</td><td>Pointer to an instance of an implementation of the <a class="el" href="classprt_1_1_callbacks.html">Callbacks</a> interface. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cache</td><td>Pointer to an instance of an implementation of the <a class="el" href="classprt_1_1_cache.html">Cache</a> interface. See <a class="el" href="classprt_1_1_cache_object.html">CacheObject</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">occlSet</td><td>The <a class="el" href="classprt_1_1_occlusion_set.html">OcclusionSet</a> which will be filled with the generated occlusionHandles. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">generateOptions</td><td>An optional <a class="el" href="classprt_1_1_attribute_map.html">AttributeMap</a> to set generate options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a status code. </dd></dl>

</div>
</div>
<a class="anchor" id="af25a90488eeae74f63442d12ac0583a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprt.html#ac35a3cef5502bd6490d1742bd427916a">LogLevel</a> prt::getLogLevel </td>
          <td>(</td>
          <td class="paramtype">Status *&#160;</td>
          <td class="paramname"><em>status</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the minimally active log level. </p>

</div>
</div>
<a class="anchor" id="a356d4059266a53b3ab45fe1ff6a66a4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* prt::getStatusDescription </td>
          <td>(</td>
          <td class="paramtype">Status&#160;</td>
          <td class="paramname"><em>stat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a human readable description based on a status value. </p>

</div>
</div>
<a class="anchor" id="a2b2c3b2fef77f2d7da8ab5919687507c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> prt::getTexturePixeldata </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cache *&#160;</td>
          <td class="paramname"><em>cache</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads and decodes a texture and copies the pixel data to the passed buffer.</p>
<p>Must be called after <a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init()</a>, will return STATUS_NOT_INITIALIZED else. Is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">uri</td><td>URI of the texture, see <a class="el" href="_app_notes.html">Application Notes</a> for URI creation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Pointer to pre-allocated buffer. The needed size can be calculated with <a class="el" href="namespaceprt.html#a785b02f26edd5ec806607ab98d5761ae">createTextureMetadata()</a> (width*height*bytesPerPixel). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bufferSize</td><td>Size of the pre-allocated buffer. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cache</td><td>Optional <a class="el" href="classprt_1_1_cache.html">Cache</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status. </dd></dl>

</div>
</div>
<a class="anchor" id="a6694b33fa488d9eaf0ff21ac43dec3e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprt_1_1_version.html">Version</a> const* prt::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="structprt_1_1_version.html">Version</a> struct with information about the current Procedural Runtime. </p>

</div>
</div>
<a class="anchor" id="a389d6191a10c5ae7dfc86dcce24c311d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classprt_1_1_object.html">Object</a>* prt::init </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *const *&#160;</td>
          <td class="paramname"><em>prtPlugins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prtPluginsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogLevel&#160;</td>
          <td class="paramname"><em>logLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LicParams *&#160;</td>
          <td class="paramname"><em>lic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Status *&#160;</td>
          <td class="paramname"><em>stat</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs global Procedural Runtime initialization. Must only be called once per process, else will fail with STATUS_ALREADY_INITIALIZED. Is thread-safe. Blocks until initialization is done. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structprt_1_1_flex_lic_params.html">FlexLicParams</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">prtPlugins</td><td>List of paths to shared libraries or paths of directories to scan for shared libraries. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">prtPluginsCount</td><td>Number of plugin paths provided. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">logLevel</td><td>Loglevel to use </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lic</td><td>Licensing Information (loader dependent). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stat</td><td>Optional pointer to return the status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A "license handle" object which must be destroyed to release the license. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c181e1d9092e6ace287a8c951b36a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t* prt::listDecoderIds </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>resultSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Status *&#160;</td>
          <td class="paramname"><em>stat</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lists all registered decoders. If the result does not fit into the allocated buffer, the result is truncated. the INOUT parameter resultSize must be compared to the original buffer size after the call to detect this situation.</p>
<p>Must be called after <a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init()</a>, will return STATUS_NOT_INITIALIZED else. Is thread-safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classprt_1_1_decoder_info.html">DecoderInfo</a>, <a class="el" href="namespaceprt.html#aaf2da61548a50cf549090a613d23ec3b">createDecoderInfo</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>Pointer to pre-allocated string to receive the semicolon-separated list of decoder ids. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">resultSize</td><td>Pointer to size of reserved buffer; receives the size of the actual result (incl. terminating 0). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stat</td><td>Optional pointer to return the status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result. </dd></dl>

</div>
</div>
<a class="anchor" id="ad45926fb4d54c985c1af7bcd904bf212"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t* prt::listEncoderIds </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>resultSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Status *&#160;</td>
          <td class="paramname"><em>stat</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lists all registered encoders. If the result does not fit into the allocated buffer, the result is truncated. the INOUT parameter resultSize must be compared to the original buffer size after the call to detect this situation.</p>
<p>Must be called after <a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init()</a>, will return STATUS_NOT_INITIALIZED else. Is thread-safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classprt_1_1_encoder_info.html">EncoderInfo</a>, <a class="el" href="namespaceprt.html#a139ddfbf80758a1e4fbbcff7bd55d404">createEncoderInfo</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>Pointer to pre-allocated string to receive the semicolon-separated list of encoder ids. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">resultSize</td><td>Pointer to size of reserved buffer; receives the size of the actual result (incl. terminating 0). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stat</td><td>Optional pointer to return the status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b4337b6cedb6d554afe1875c874047f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> prt::log </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogLevel&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Injects a log message into the PRT log dispatcher, can be called at any time (also before <a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init()</a>). Is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Message to log. </td></tr>
    <tr><td class="paramname">level</td><td>LogLevel of the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e58922795880d9c4e5200f05ca0ae07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> prt::removeLogHandler </td>
          <td>(</td>
          <td class="paramtype">LogHandler *&#160;</td>
          <td class="paramname"><em>logHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a previously registered log handler, can be called at any time (also before <a class="el" href="namespaceprt.html#a389d6191a10c5ae7dfc86dcce24c311d">init()</a>). Is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logHandler</td><td><a class="el" href="classprt_1_1_log_handler.html">LogHandler</a> to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status. </dd></dl>

</div>
</div>
<a class="anchor" id="a134acce0e87126ded51dcbe9b1f9299b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprt.html#acf0b3066b48a14bccb756bee9a4700e4">Status</a> prt::setLogLevel </td>
          <td>(</td>
          <td class="paramtype">LogLevel&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the minimally active log level. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceprt.html">prt</a></li>
    <li class="footer">Generated on Fri Jun 9 2017 18:28:05 for Esri Procedural Runtime by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>

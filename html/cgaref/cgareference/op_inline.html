<html>

<head>
	<title>Rule inlining</title>
	<link rel="stylesheet" href="../manual_style.css" type="text/css" />
</head>

<body>
<div class="content">

<table summary="" class="header">
	<tr>
		<td align="left" class="helphead_l"><a href="../toc.html"><div class="helplink">&nbsp;</div></a></td>
		<td align="right" class="helphead_r"></td>
	</tr>
</table>

<h1>Rule inlining</h1>

<h2>Syntax</h2>

<p class="code2"><span class="cga_op">inline</span> <span class="cga_opparam">Rule</span></p>
<p class="code2"><span class="cga_op">inline</span> <span class="cga_opparam">subdivision</span></p>
<p class="code2"><span class="cga_op">inline</span> { <span class="cga_opparam">operations</span> }</p>

<p class="code2"><span class="cga_op">inline</span>(<span class="cga_opparam">geometryMergeStrategy</span>) <span class="cga_opparam">Rule</span></p>
<p class="code2"><span class="cga_op">inline</span>(<span class="cga_opparam">geometryMergeStrategy</span>) <span class="cga_opparam">subdivision</span></p>
<p class="code2"><span class="cga_op">inline</span>(<span class="cga_opparam">geometryMergeStrategy</span>) { <span class="cga_opparam">operations</span> }</p>

<h2>Parameters</h2>

<ul>
    <li><span class="cga_opparam">geometryMergeStrategy</span> (selector)
    <br>Defines how the geometry of the resulting shapes are combined:  
	<table cellspacing="5">
		<tr><td width="20%"><span class="codelight">append</span></td><td>Default. Appends the geometry as is.</td></tr>
		<tr><td width="20%"><span class="codelight">unify</span></td><td>Uses the Boolean union operation.</td></tr>	
	</table>
	</li>
	<li>Syntax options: 
	<table cellspacing="5">
		<tr><td width="20%"><span class="codelight">Rule</span></td><td>Name of a rule.</td></tr>
		<tr><td width="20%"><span class="codelight">subdivision</span></td><td>A subdivison operation (see <a class="normw" href="cgaindex.html#geometrysubdivision">Geometry Subdivision</a>).</td></tr>
		<tr><td width="20%"><span class="codelight">operations</span></td><td>A sequence of shape operations in curly brackets.</td></tr>
		
	</table>
	</li>
</ul>

<h2>Description</h2>
The <span class="codelight">inline</span> keyword triggers the immediate derivation of the specified rule, subdivision operation, or shape operation sequence. The resulting shapes are then automatically merged into a single shape that replaces the current shape.
In case it results in a single shape, it is taken as is. If it results in multiple shapes, their geometries are combined according to the <span class="codelight">geometryMergeStrategy</span>. By default (if no strategy is specified) the geometries are just appended.
<br>If the inlined shapes have conflicting material attributes, each shape's material is written to the geometry, meaning that all materials are preserved. For other attributes, the value of the current shape is kept if the inlined shapes have conflicting values or if more than one <a class="normw" href="op_set.html">set</a> operation has occurred.
<h3>Concept</h3>
<table>
<tr>
	<td class="twocol_l"><img src="images/inline_concept_initialShape.png" alt="Initial shape"/></td>
    <td class="twocol_r">
        <em>This is the initial shape.</em>
    </td>
</tr>
<tr>
    <td class="twocol_l"><img src="images/inline_concept_before.png" alt="Shape tree normal"/></td>
    <td class="twocol_r">
        <em><p>Two rules are applied to the initial shape: <span class="codelight">Volumes</span> splits the shape and inserts different assets, while <span class="codelight">Colorize</span> sets a yellow color.
        The rules modify the input shape independently and do not affect each other. </p>
        <p>This can be observed in the Model Hierarchy where both rules represent the root of a separate shape subtree. The leaf shapes in the full shape tree collectively form the visible model.</p></em>
	
	<pre class="codecga">
Init -->
    Volumes
    Colorize

Colorize --> color(1,1,0) Yellow.

Volumes --> split(x) { '0.5: A | '0.5: B }
    
A --> split(z) { '0.5: Sphere   | '0.5: Beethoven }
B --> split(z) { '0.5: Cylinder | '0.5: Cone }
    
Sphere    --> primitiveSphere
Cylinder  --> primitiveCylinder
Cone      --> primitiveCone
Beethoven --> i("beethoven.obj")
</pre>
	</td>
</tr>
</table>
<br><br>
<table>
<tr>
	<td class="twocol_l"><img src="images/inline_concept_after.png" alt="Shape tree after inline"/></td>
	<td class="twocol_r">
        <em>
            <p>Inlining <span class="codelight">Volumes</span> enables the two rules to be sequentialized, allowing <span class="codelight">Colorize</span> to take the combined result of <span class="codelight">Volumes</span> as input.</p>
            <p>Essentially, an inlined rule can be used like a built-in shape operation (e.g., <a class="normw" href="op_extrude.html">extrude</a>) to directly modify the current shape.</p>
        </em>
<pre class="codecga">
Init -->
    inline Volumes
    Colorize
</pre>
        <em>The subtree generated by an inlined rule (e.g., <span class="codelight">Volumes</span>) is collapsed and removed from the Model Hierarchy, providing control over the derivation order as well as the structure of the shape tree.</em>
	</td>
</tr>
</table>

<h3>Geometry merge strategy</h3>
The correct <span class="codelight">geometryMergeStrategy</span> depends on the modeling objective. Currently, two strategies are offered:
<table cellspacing="5">
	<tr><td width="20%"><span class="codelight">append</span></td><td>Default. Used to simply collect the geometries of multiple shapes and put them into a single mesh. No geometry cleanup is performed and all components are kept as is.</td></tr>
	<tr><td width="20%"><span class="codelight">unify</span></td><td>Used to combine the geometries of intersecting shapes with Boolean operations. Intersecting faces get topologically connected and inner faces are removed.</td></tr>	
</table>

</p>

<h2>Related</h2>
<ul>
    <li><a class="normw" href="op_boolOp.html">union, subtract, intersect operations</a></li>
	<li><a class="normw" href="op_tag.html">tag operation</a></li>
    <li><a class="normw" href="cga_componentTags.html">Geometry Tagging: Essential Knowledge</a></li>
</ul>

<h2><a name="examples"></a>Examples</h2>

<h3>Mesh Topology</h3>

</table>
<br><br>
<table>
<tr>
	<td class="twocol_l"><img src="images/inline_append_topology.png" alt="Inline append topology." width="298"/></td>
	<td class="twocol_r">
<pre class="codecga">
Init -->
    primitiveCube
    print("start: " + geometry.nVertices)
    inline comp(f) { all: SetColor }
    print("inlined: " + geometry.nVertices)
    cleanupGeometry(vertices, 0)
    print("cleanup: " + geometry.nVertices)
    
rampValue = comp.index/comp.total
SetColor -->
    set(material.opacity, 0.9)
    color(colorRamp("spectrum", rampValue))
</pre>
	<em>Inlining is used to combine the colored faces of a cube back into a single shape. The faces are simply appended and thus do not share vertices. This can be fixed using <a class="normw" href="op_cleanupGeometry.html">cleanupGeometry</a>.</em>
	</td>
</tr>
</table>

<h3>F-Shaped Building</h3>
<table>
<tr>
	<td class="twocol_l"><img src="images/inline_fshape_before.png" alt="F-Shaped Building traditionally" width="298"/></td>
	<td class="twocol_r">
<pre class="codecga">
Init -->
    split(z, noAdjust) 
        {  7: split(x) { ~7: House | 7: House }*
        | ~1: split(x) { ~7: NIL   | 7: House }* }

House --> 
    extrude(5)
    comp(f) { side: Fac. | top: roofGable(40) Roof. }
</pre>
	<em>Without inlining: The initial shape is split into an F-shape. Each piece is separately extruded and a separate detached roof is built on top.</em>
	</td>
</tr>
</table>
<br><br>
<table>
<tr>
	<td class="twocol_l"><img src="images/inline_fshape_after.png" alt="F-Shaped Building with inlining" width="298"/></td>
	<td class="twocol_r">
<pre class="codecga">
Init -->
    inline FShapePieces
    cleanupGeometry(all, 0)
    House
	
FShapePieces -->
    split(z, noAdjust) 
        {  7: split(x) { ~7: Done. | 7: Done. }*
        | ~1: split(x) { ~7: NIL   | 7: Done. }* }
</pre>
	<em>With inlining: The <span class="codelight">FShapePieces</span> rule is inlined, which combines all pieces into a single shape. With <span class="codelight">append</span> the geometry is kept as is, which means the pieces are not connected via shared edges. To connect them and merge them into a single footprint polygon, the <a class="normw" href="op_cleanupGeometry.html">cleanupGeometry</a> operation is used. This results in a single extruded mass and a single joint roof. </em>
	</td>
</tr>
</table>

<h3>Best of Two Alternatives</h3>

<table>
<tr>
	<td class="twocol_l"><img src="images/inline_best_alternative.png" alt="Best of several alternatives" width="298"/></td>
	<td class="twocol_r">
<pre class="codecga">
Init --> 
    inline {
        [ tag("LayoutA") LayoutA ]
        [ tag("LayoutB") LayoutB ]
    }
    ChooseLayout

LayoutA --> offset(-15, border)
LayoutB --> split(x) { 15: Lot. | ~10: NIL }*

taggedArea(name) = 
    sum(comp(f) { isTagged(name): geometry.area })

ChooseLayout -->
    case taggedArea("LayoutA") > taggedArea("LayoutB"):
          comp(f) { isTagged("LayoutA")= Mass }
    else: comp(f) { isTagged("LayoutB")= Mass }

Mass --> extrude(30)
</pre>
	<em>Two different and tagged layouts are generated. Using <span class="codelight">inline(append)</span> they are combined into a single shape. 
	The <a class="normw" href="func_comp.html">comp</a> function and tags are then used to compare the area of both layouts and continue only with the larger one. 
	</em>
	</td>
</tr>
</table>

<h3>Unify Spiral Steps</h3>

<table>
<tr>
	<td class="twocol_l"><img src="images/inline_spiral_stairs.png" alt="Spiral Stairs" width="298"/></td>
	<td class="twocol_r">
<pre class="codecga">
Init --> 
    inline(unify) StepsRec(18)
    color(0, 1, 0, 0.8)

StepsRec(nSteps) -->
    case nSteps > 0: 
        Step
        r(0, 20, 0)
        t(0, 0.18, 0)
        StepsRec(nSteps-1)
    else: 
        NIL
        
Step -->  s(0.4, 0.3, 1) primitiveCube
</pre>
	<em>The <span class="codelight">StepsRec(nSteps)</span> rule recursively generates the steps of the spiral stairs. 
	When the rule is inlined using <span class="codelight">unify</span>, the steps are combined into a single shape and their geometries merged into a single watertight mesh using Boolean 3D union operations. 
	</em>
	</td>
</tr>
</table>

<h3>Inline and Tags</h3>

<table>
<tr>
	<td class="twocol_l"><img src="images/inline_unify_tags_3D.png" alt="Example of inline with tags 3D" width="298"/></td>
	<td class="twocol_r">
<pre class="codecga">
Init -->
    inline(unify) split(x) { 3: A | 4: B | 3: C }
    comp(f) { isTagged("A"): Blue
            | isTagged("B"): Yellow
            | isTagged("C"): Red }
	
A --> primitiveCylinder tag("A")
B --> t(-1, 0.5, 0.75)  
      s(6, 2, 1.5)
      primitiveCube
      tag("B")
C --> primitiveSphere tag("C")
</pre>
	<em>The initial shape is split into three parts, with a different primitive geometry asset inserted into each part and then <a class="normw" href="op_tag.html">tagged</a>. Inlining the <span class="codelight">split</span> using <span class="codelight">unify</span> merges them into a single watertight mesh while preserving the tags on the individual face components.</em>
	</td>
</tr>
</table>
<br><br>
<table>
<tr>
	<td class="twocol_l"><img src="images/inline_unify_tags_2D.png" alt="Example of inline with tags 2D" width="298"/></td>
	<td class="twocol_r">
<pre class="codecga">
Init -->
    inline(unify) split(x) { 3: A | 4: B | 3: C }
    comp(f) { isTagged("A") && isTagged("B"): Green 
            | isTagged("B") && isTagged("C"): Orange
            | isTagged("A")                 : Blue
            | isTagged("B")                 : Yellow
            | isTagged("C")                 : Red }

A --> primitiveDisk tag("A")
B --> t(-1, 0, 0.75)  
      s(6, 0, 1.5)
      tag("B")
C --> tag("C")

Blue -->   color("#0399F5")
Green -->  color("#09DE1F")
Yellow --> color("#FADB19")
Red -->    color("#FF360A")
Orange --> color("#FA9100")
</pre>
	<em>The same example in 2D. All original edges and tags are preserved, allowing to identify the intersecting parts using tags.</em>
	</td>
</tr>
</table>



<!-- FOOTER -->

<p class="foot">Copyright &copy;2008-2025 Esri R&D Center Zurich. All rights reserved.</p>				  

<!-- END CENTERED CONTENT -->

</div>
</body>
</html>